{"meta":{"title":"VictorV的小博客","subtitle":"","description":"记录一些懒得找的东西, 和一些想写的东西","author":"VictorV","url":"http://474172261.github.io","root":"/"},"pages":[],"posts":[{"title":"说我之前的leader 唐青昊, 也是第一次见识到的这样卑鄙的人","slug":"fuck_tqh","date":"2020-03-29T07:15:15.805Z","updated":"2020-03-29T10:19:26.380Z","comments":true,"path":"2020/03/29/fuck_tqh/","link":"","permalink":"http://474172261.github.io/2020/03/29/fuck_tqh/","excerpt":"一直懒得吐槽唐青昊🖕，毕竟遇到糟糕的leader大不了走人，但是有些东西会随着时间忘记，导致后来的人继续掉坑里。所以还是发个文，曝光一下这个人，让大家认清这个人，不要被他简历上的”成就”蒙蔽了双眼。","text":"一直懒得吐槽唐青昊🖕，毕竟遇到糟糕的leader大不了走人，但是有些东西会随着时间忘记，导致后来的人继续掉坑里。所以还是发个文，曝光一下这个人，让大家认清这个人，不要被他简历上的”成就”蒙蔽了双眼。 本来这个帖子是发到看雪的, 一开始还正常, 后来版主把帖子移到比较私密的会员区了, 背离了我让大家避坑的初衷, 没办法, 重新把blog整起来, 帮助大家看清楚这个人。 一搜他，网上也是有不少的资料，我这个故事呢，从他带领 360 的marvel团队那年开始(他已经不在360了)。一部分内容是听说的，但是也基本上没假的。（该团队在核心大牛走得差不多后就解散了，他跳槽离开的时候还没有解散，只剩下开发团队的人，后来才算真解散了） 首先，第一个要说的就是有他名字的cve号qemu的多个cve号里，虽然有他名字，但是都和他无关，都是团队里的其它成员发现的。只不过他仗着自己是leader， 用自己的名义去提交给官方，所以cve的公开信息里只有他的名字，真的发现者的名字却没有。当然就算有怨气，人在屋檐下，其他人也没办法。 第二个就是关于他的那些虚拟化逃逸的技术演讲无论是讲qemu的逃逸[1]，还是vmware workstation的逃逸[2]，技术上都和他没有一点关系。强行利用自己leader身份凑一起出去演讲，对外塑造一副自己是发现者的形象，着实卑劣。另外他要求技术大牛给他讲workstation逃逸的利用细节，本来是别人发现的利用技术，他就想占位己有，把要来的大牛的利用exp自己改个格式，写个注释，对外当作是自己写出来的样子。 第三个就是出书了他的那本《云虚拟化安全攻防实践》书，本来是团队凑一起写了出书，收益大家均分，这个当时都有一个临时协议纸条， 大家都有签名。后来因为核心技术研究员都被逼走了，他就说要不大家把书出完吧。本来有始有终对大家都好，但是他耍心眼，不肯把整书拿出来让大家看，还私下找一些参与者说一起出书，把其他人忽略掉，最后可能有人不同意所以被迫听取一下大家意见。鉴于他的无耻，我也就没同意把我写的那部分发布在书里，当然其它几个成员也没同意。 但是最后他还是无耻地把书给出了，还把我和其它几个技术成员的内容改得面目全非。对比他的书和我发布的帖子“QEMU 与 KVM 虚拟化安全研究介绍”以及看雪关于hyper-v的帖子Hyper-V安全从0到1(1)，就知道他盗用了多少，改得多烂。另外, 真正由他写的内容也就第一章, 由于版权原因, 他就更换了一些内容, 把其它人给他的分析报告, 修修改改写进书里了。 第四个他偷偷报大牛的洞在团队技术大牛已经走了的情况下，他偷偷把大牛没有上报的bug报了领取奖励，这事不是一般的下流。而且干了不止一次。 最后呢这些都是旧事了，但是萌新可能不知道，一些想邀请他的人也不知道，写个帖子，留作记录，给大家避坑。 其它关于他为人处事的故事我不必多说，坊间都有”佳话”，至于事实证明，可以问当事人，想必你肯定可以听到更有意思的故事(❛ᴗ❛) 还有件事就是，任何时候，都不要把自己的办公电脑密码给别人，除非你很信得过那个人！！！ 我当时因为不想跟着这混蛋，又因为一些其它原因，就没有换团队，而是打算离开360。17年7月的时候毕业了，准备回去办离职，忘了因为什么事情（好像是我需要远程登录吧），就让他帮我登录了下我的办公电脑。后来我怕他乱动我的文件，就给一些文件加密了，因为远程vpn连接不方便直接改密码，所以没改。后来准备办离职，需要登录，结果我的密码被他改了，他还不肯告诉我，说怕我泄露公司机密。excuse me？？我自己的办公电脑，有啥我自己不能看的？我都还没有办离职，看自己电脑怎么了？ 其实就是他想偷看我的文件，结果发现我加密了文件，所以他就把我密码改了（这个不是猜的，他说的）。搞得我没办法正常离职，后来不了了之（因为是实习，实习协议也到期了，我也给了我该给的交接文件）。 这件事我只能说是我自己太单纯，写出来也是给萌新提个醒，不要轻易信任别人而给出你的密码。 相关技术演讲[1] Wei Xiao, Qinghao Tang, “qemu+kvm &amp; xen pwn: virtual machine escape from ‘Dark Portal’” [2] CSW2017 Qinghao tang+Xinlei ying vmware_escape_final 方便大家吃瓜, 给个对比图 贴下之前的评论","categories":[],"tags":[]},{"title":"linux 内核和用户态通信之 /proc文件系统","slug":"linux-proc","date":"2020-03-29T07:00:54.368Z","updated":"2020-03-29T10:19:39.093Z","comments":true,"path":"2020/03/29/linux-proc/","link":"","permalink":"http://474172261.github.io/2020/03/29/linux-proc/","excerpt":"/proc 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在 Linux® 内核空间和用户空间之间进行通信。在 /proc 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的.","text":"/proc 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在 Linux® 内核空间和用户空间之间进行通信。在 /proc 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的. /proc 文件系统包含了一些目录（用作组织信息的方式）和虚拟文件。虚拟文件可以向用户呈现内核中的一些信息，也可以用作一种从用户空间向内核发送信息的手段。 创建一个/proc文件在3.8内核之前,使用create_proc_entry创建一个文件,原型如下: 1234567891011121314151617181920struct proc_dir_entry *create_proc_entry( const char *name, mode_t mode, struct proc_dir_entry *parent );//创建一个虚拟文件struct proc_dir_entry &#123; const char *name; // 节点名称 mode_t mode; // 权限,与chmod的一样,可以使用八进制表示 uid_t uid; // File's user id gid_t gid; // File's group id struct inode_operations *proc_iops; // 索引节点操作函数 struct file_operations *proc_fops; // 文件操作函数 struct proc_dir_entry *parent; // 父目录,如果是NULL,就代表/proc目录 ... read_proc_t *read_proc; // 输出给cat的函数 write_proc_t *write_proc; // 读取用户输入的函数 void *data; // 指向private 数据 atomic_t count; // 使用计数 ...&#125;;void remove_proc_entry( const char *name, struct proc_dir_entry *parent );//不仅可以删除节点,还能删除proc_mkdir创建的目录struct proc_dir_entry *proc_mkdir(const char *name, struct proc_dir_entry *parent); //创建一个虚拟目录 parent 参数可以为 NULL（表示 /proc 根目录），也可以是很多其他值 proc_dir_entry 在文件系统中的位置 proc_root_fs /proc proc_net /proc/net proc_bus /proc/bus proc_root_driver /proc/driver 如果我们想创建一个文件为test_modul的虚拟文件,就这样初始化 1234create_proc_entry( \"test_module\", 0644, NULL );或者pt_root = proc_mkdir(\"test_menu\", NULL);pt_entry1 = create_proc_entry(USER_ENTRY1, 0666, pt_root); /proc文件交互函数read_proc 供用户读取的函数 1234567int mod_read( char *page,//数据写入的位置,该page缓冲区在内核 char **start, off_t off, int count,//定义写入的最大字节数 int *eof, //当数据写入完后,需要设置为1 void *data //private 数据 ); 当需要写入多页数据时(一般一页4Kb),需要用到 start,off. write_proc 读取用户的输入 12345int mod_write( struct file *filp, //指向一个打开的文件结构 const char __user *buff, //用户输入的数据,buff在用户空间,内核要读取需要用到copy_from_user unsigned long len, //长度 void *data ); 其它需要用到的函数 1234567891011121314151617181920212223242526/* 创建一个符号链接 */struct proc_dir_entry *proc_symlink( const char *name, struct proc_dir_entry *parent, const char *dest );/* Create a proc_dir_entry with a read_proc_t in one call */struct proc_dir_entry *create_proc_read_entry( const char *name, mode_t mode, struct proc_dir_entry *base, read_proc_t *read_proc, void *data );/* 从内核空间复制数据到用户空间 */unsigned long copy_to_user( void __user *to, const void *from, unsigned long n );/* 从用户空间到内核 */unsigned long copy_from_user( void *to, const void __user *from, unsigned long n );/* 创建虚拟的连续内存块 */void *vmalloc( unsigned long size );/* 释放vmalloc创建的块 */void vfree( void *addr );/* Export a symbol to the kernel (make it visible to the kernel) */EXPORT_SYMBOL( symbol );/* Export all symbols in a file to the kernel (declare before module.h) */EXPORT_SYMTAB 创建内核驱动123456789101112131415161718#include &lt;linux/module.h&gt;/* Defines the license for this LKM */MODULE_LICENSE(\"GPL\");int my_module_init( void )//自定义的初始化函数&#123; printk(KERN_INFO \"my_module_init called. Module is now loaded.\\n\"); return 0;&#125;void my_module_cleanup( void )//自定义的退出函数&#123; printk(KERN_INFO \"my_module_cleanup called. Module is now unloaded.\\n\"); return;&#125;module_init( my_module_init );//声明初始化函数module_exit( my_module_cleanup );//声明退出函数 从3.10内核开始,create_proc_entry() 函数被替换成proc_create() 函数函数区别如下: 123456proc_file = create_proc_entry(\"file\",0600,NULL);if (proc_file) &#123; proc_file-&gt;read_proc = file_read; proc_file-&gt;write_proc = file_write; proc_file-&gt;owner = THIS_MODULE;&#125; 编译安装驱动Makefile 1234567obj-m +&#x3D; simple-km.oall: make -C &#x2F;lib&#x2F;modules&#x2F;&#96;uname -r&#96;&#x2F;build SUBDIRS&#x3D;$(PWD) modulesclean: make -C &#x2F;lib&#x2F;modules&#x2F;&#96;uname -r&#96;&#x2F;build SUBDIRS&#x3D;$(PWD) modules 开头的是tab, 不是空格, 一定要注意 执行如下命令 12345$ make$ insmod simple-km.ko $ dmesg | tail -5 查看最后5行信息$ lsmod$ rmmod simple-km.ko 一个简单的示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/vmalloc.h&gt;#include &lt;asm/uaccess.h&gt;MODULE_LICENSE(\"GPL\");MODULE_DESCRIPTION(\"Fortune Cookie Kernel Module\");MODULE_AUTHOR(\"VictorV\");#define MAX_COOKIE_LENGTH PAGE_SIZEstatic struct proc_dir_entry *proc_entry;static char *cookie_pot; // 内存缓冲区static int cookie_index; // 指向缓冲区的数据尾部static int next_fortune; // 通过\\0分开字符串,此处用来指向下一个需要输出的缓冲字符串ssize_t fortune_write( struct file *filp, const char __user *buff, unsigned long len, void *data )&#123; int space_available = (MAX_COOKIE_LENGTH-cookie_index)+1; if (len &gt; space_available) &#123; printk(KERN_INFO \"fortune: cookie pot is full!\\n\"); return -ENOSPC; &#125; if (copy_from_user( &amp;cookie_pot[cookie_index], buff, len )) &#123; //从用户空间读取数据到cookie_pot, return -EFAULT; &#125; cookie_index += len; cookie_pot[cookie_index-1] = 0;//将最后一位置零 return len;&#125;int fortune_read( char *page, char **start, off_t off,int count, int *eof, void *data )&#123; int len; if (off &gt; 0) &#123; *eof = 1; return 0; &#125; if (next_fortune &gt;= cookie_index) next_fortune = 0;//超过数据个数,就循环读取 len = sprintf(page, \"%s\\n\", &amp;cookie_pot[next_fortune]);//将一段字符串写入page next_fortune += len; return len;&#125;int init_fortune_module( void )//初始化&#123; int ret = 0; cookie_pot = (char *)vmalloc( MAX_COOKIE_LENGTH );//申请一段内核空间 if (!cookie_pot) &#123; ret = -ENOMEM; &#125; else &#123; memset( cookie_pot, 0, MAX_COOKIE_LENGTH ); proc_entry = create_proc_entry( \"fortune\", 0644, NULL ); if (proc_entry == NULL) &#123; ret = -ENOMEM; vfree(cookie_pot); printk(KERN_INFO \"fortune: Couldn't create proc entry\\n\"); &#125; else &#123; cookie_index = 0; next_fortune = 0; proc_entry-&gt;read_proc = fortune_read;//这里定义输出函数 proc_entry-&gt;write_proc = fortune_write;//定义输入函数 proc_entry-&gt;owner = THIS_MODULE; printk(KERN_INFO \"fortune: Module loaded.\\n\"); &#125; &#125; return ret;&#125;void cleanup_fortune_module( void )&#123; remove_proc_entry(\"fortune\", &amp;proc_root); vfree(cookie_pot); printk(KERN_INFO \"fortune: Module unloaded.\\n\");&#125;module_init( init_fortune_module );module_exit( cleanup_fortune_module ); 效果: 123456789101112[root@plato]# insmod fortune.ko[root@plato]# echo \"Success is an individual proposition. Thomas Watson\" &gt; /proc/fortune[root@plato]# echo \"If a man does his best, what else is there? Gen. Patton\" &gt; /proc/fortune[root@plato]# echo \"Cats: All your base are belong to us. Zero Wing\" &gt; /proc/fortune[root@plato]# cat /proc/fortuneSuccess is an individual proposition. Thomas Watson[root@plato]# cat /proc/fortuneIf a man does his best, what else is there? General Patton[root@plato]#","categories":[],"tags":[]},{"title":"windows 内核调试配置","slug":"windows-debug-setting","date":"2020-03-29T06:43:22.521Z","updated":"2020-03-29T10:16:20.967Z","comments":true,"path":"2020/03/29/windows-debug-setting/","link":"","permalink":"http://474172261.github.io/2020/03/29/windows-debug-setting/","excerpt":"","text":"添加串口到虚拟机安装好虚拟机后, 添加串口设配, 配置如下 配置虚拟机windows系统(简称Guest)按组合键win+r, 输入 msconfig.做如下配置重启虚拟机 配置外部主机(检查Host)找到windbg的快捷方式, 右键属性, 添加参数-b -k com:port=\\\\.\\pipe\\com_1,baud=115200,pipe” 连接调试器在Guest启动后, 在Host打开刚才设置的windbg快捷方式, 如下便连接成功 添加符号","categories":[],"tags":[]},{"title":"Linux双虚拟机调试","slug":"linux-debug-setting","date":"2020-03-29T06:22:04.760Z","updated":"2020-03-29T10:19:44.776Z","comments":true,"path":"2020/03/29/linux-debug-setting/","link":"","permalink":"http://474172261.github.io/2020/03/29/linux-debug-setting/","excerpt":"","text":"准备内核linux kernel source 配置虚拟机 新建一个虚拟机 添加串口, 并做如下配置此虚拟机作为被调试机 克隆虚拟机 修改串口设备的配置,设定为”该端为客户端”, 此为调试机 在被调试机编译内核 解压内核 12tar jxvf linux-2.6.26.tar.bz2cd linux-* 配置编译参数 1make menuconfig 可能的错误 12345678error: curses.h: No such file or directory基于Debian的发行版（如Debian、Ubuntu）：sudo apt-get install libncurses5-dev基于Red Hat的发行版（如RHEL、CentOS）：sudo yum install ncurses-devel如果出现找不到该包，尝试以下设置：vi &#x2F;etc&#x2F;apt&#x2F;source.list添加其它系统的源[源列表地址](http:&#x2F;&#x2F;mirrors.163.com&#x2F;.help&#x2F;debian.html)比如kali,我添加的debian jessie的源 如果提示窗口太小出错,说明你的命令行窗口小了,放大一点再试试.内核调试需要做如下设置: 1234567Kernel Hacking –&gt; compile-time checks and compiler options –&gt; [*] Compile the kernel with debug info [*] Compile the kernel with frame pointers [*] kernel debugging [*] KGDB: kernel debugger–&gt; &lt;*&gt; KGDB: use kgdb over the serial console 完成上述选项后, 直接save后推出. 编译内核 1234make -j 4 bzImage # -j 代表用多少线程, 不要超过cpu的最大线程数make modulesmake modules_installmake install 修改启动表打开 /boot/grub/grub.conf (如果不存在, 就改grub.cfg文件)针对 grub.conf 123456789101112131415161718192021 1 # grub.conf generated by anaconda 2 # 3 # Note that you do not have to rerun grub after making changes to this file 4 # NOTICE: You have a &#x2F;boot partition. This means that 5 # all kernel and initrd paths are relative to &#x2F;boot&#x2F;, eg. 6 # root (hd0,0) 7 # kernel &#x2F;vmlinuz-version ro root&#x3D;&#x2F;dev&#x2F;VolGroup00&#x2F;LogVol00 8 # initrd &#x2F;initrd-version.img 9 #boot&#x3D;&#x2F;dev&#x2F;hda10 default&#x3D;011 timeout&#x3D;512 splashimage&#x3D;(hd0,0)&#x2F;grub&#x2F;splash.xpm.gz13 hiddenmenu14 title CentOS (2.6.26)15 root (hd0,0)16 kernel &#x2F;vmlinuz-2.6.26 ro root&#x3D;&#x2F;dev&#x2F;VolGroup00&#x2F;LogVol00 17 initrd &#x2F;initrd-2.6.26.img18 title CentOS-4 i386 (2.6.9-67.ELsmp)19 root (hd0,0)20 kernel &#x2F;vmlinuz-2.6.9-67.ELsmp ro root&#x3D;&#x2F;dev&#x2F;VolGroup00&#x2F;LogVol00 &lt;---------------------21 initrd &#x2F;initrd-2.6.9-67.ELsmp.img 在kernel那一行末尾添加 “kgdboc=ttyS0,115200”如下图:针对 grub.cfg: 123456789101112131415161718192021menuentry &#39;Ubuntu, with Linux 3.8.0-19-generic&#39; --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option &#39;gnulinux-3.8.0-19-generic-advanced-af5e68c6-4f1f-494e-8c35-fc0911ec3564&#39; &#123;recordfail load_video gfxmode $linux_gfx_mode insmod gzio insmod part_msdos insmod ext2 set root&#x3D;&#39;hd0,msdos1&#39; if [ x$feature_platform_search_hint &#x3D; xy ]; then search --no-floppy --fs-uuid --set&#x3D;root --hint-bios&#x3D;hd0,msdos1 --hint-efi&#x3D;hd0,msdos1 --hint-baremetal&#x3D;ahci0,msdos1 af5e68c6-4f1f-494e-8c35-fc0911ec3564 else search --no-floppy --fs-uuid --set&#x3D;root af5e68c6-4f1f-494e-8c35-fc0911ec3564 fi echo &#39;Loading Linux 3.8.0-19-generic ...&#39; linux &#x2F;boot&#x2F;vmlinuz-3.8.0-19-generic root&#x3D;UUID&#x3D;af5e68c6-4f1f-494e-8c35-fc0911ec3564 ro find_preseed&#x3D;&#x2F;preseed.cfg auto noprompt priority&#x3D;critical locale&#x3D;en_US kgdboc&#x3D;ttyS0,115200 kgdbwait quiet ^ | ------------- echo &#39;Loading initial ramdisk ...&#39; initrd &#x2F;boot&#x2F;initrd.img-3.8.0-19-generic&#125; 在新内核对应的内容下添加 “kgdboc=ttyS0,115200” 测试双机调试开启两个虚拟机, 在被调试机上运行命令 1echo hello &gt;/dev/ttyS0 在调试机上运行 1cat /dev/ttyS0 如果调试机没有收到消息, 就实时用/dev/ttyS1, 多试两下就行如果成功了, 记得改grub的配置. 开始调试如果grub没有配置”kgdbwait”参数, 就在被调试机开机后输入 1echo g &gt;/proc/sysrq-tirgger 在调试机里 1234567891011$ gdb linux-3.18.34&#x2F;vmlinux.....(gdb) set remotebaud 115200(gdb) target remote &#x2F;dev&#x2F;ttyS0Remote debugging using &#x2F;dev&#x2F;ttyS0kgdb_breakpoint () at kernel&#x2F;kgdb.c:16741674 wmb(); &#x2F;*Sync point after breakpoint *&#x2F;warning: shared library handler failed to enable breakpoint(gdb) 如果”set remotebaud 115200”的时候出错,就换成”set serial baud 115200” 调试自定义驱动有空再说吧.","categories":[],"tags":[]},{"title":"使用github搭建自己的博客","slug":"build-blog","date":"2020-03-29T03:25:13.016Z","updated":"2020-03-29T10:19:51.818Z","comments":true,"path":"2020/03/29/build-blog/","link":"","permalink":"http://474172261.github.io/2020/03/29/build-blog/","excerpt":"","text":"首先你需要在github创建一个仓储 安装git,npmwindows下载node.js下载git 安装hexo1npm install hexo --save (或者npm install hexo-cli -g) 初始化12hexo init MYBLOGcd MYBLOG “MYBLOG”是目录名称 测试123$ hexo generate$ hexo serverINFO Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop. 浏览器访问http://localhost:4000 添加主题访问主题库添加主题, 我比较喜欢Apollo 不过不更新了, 暂时用 next 主题. 配置github推送获取链接修改MYBLOG/_config.yml文件 创建sshkey在git-bash里面使用如下指令（通过在Hexo文件夹右键选择 “Git bash here”打开） 1ssh-keygen -t rsa -b 4096 -C &quot;邮件地址@youremail.com&quot; 然后根据提示enter就好(注意文件保存的位置！！) 登录github, 在Account Settings—&gt;SSH Public keys —&gt; add another public keys中添加你的sshkey.pub文件的内容 测试key 1ssh -T git@github.com 新建文章1hexo n \"网站标题\" 文章文件在Hexo\\source_posts里面，后缀为md这是一个markdown文件，具体语法查看markdown语法 文章内容： title: 文章名date: 2013-05-29 07:56:29 #发表日期updated: 2016-04-06 14:58:03 #更新日期categories: Life #文章分类description: 你对本页的描述tags: [tag1,tag2] #文章标签. 多标签时使用英文逗号隔开photos: #如果使用Fancybox（文章头部展示图片）. 如此设置 URL1URL2#从这里开始 #就是正文 #使用markdown 推送文章1hexo d -g d 是deploy缩写 绑定域名 申请域名 添加选项 在github项目根目录添加CNAME文件, 内容我你的域名(比如 xxx.com) 进入github setting查看往下拉, 出现如下结果就成功了 在文章中添加图片第一种: 是在MYBLOG\\source目录下的images目录里添加图片, 这样在首页也能引用第二种: 1npm install https://github.com/CodeFalling/hexo-asset-image --save 假设MYBLOG\\source_posts里面的结构如下:firstblog├── apppicker.jpg├── logo.jpg└── rules.jpgfirstblog.md目录名必须与md文件名一致, 使用 ![](firstblog/logo.jgp)就可以了.","categories":[],"tags":[]},{"title":"Linux 使用技巧","slug":"linux-skill","date":"2020-03-28T23:53:23.767Z","updated":"2020-03-29T10:19:33.800Z","comments":true,"path":"2020/03/29/linux-skill/","link":"","permalink":"http://474172261.github.io/2020/03/29/linux-skill/","excerpt":"","text":"不定期更新 两个linux文件互传1$ scp -r linux-2.6.26 root@(目标ip)IP:/usr/src/(假设放到/usr/src路径) 将一个本地程序做成一个本地服务程序1$ socat tcp-l:2333,reuseaddr,fork exec:./pwn1 服务端口在2333，使用nc 127.0.0.1 2333连接 快速转换图片格式，修改分辨率12$ convert -resize 100x100 src.jpg dst.jpg$ convert -resize 50%x50% src.jpg dst.jpg 修改文件的用户12345678查看归属：$ ls -l file赋给用户hv$ chown hv:hv file如果需要把某个文件夹下所有都付给某个用户$ chown hv:hv -R dir/* 修改terminal的显示路径1$ vim ~/.bashrc 找到 1234## If this is an xterm set the title to user@host:dircase “$TERM” inxterm|rxvt)PS1&#x3D;”\\e]0;$debianchroot:+($debianchroot)\\u@\\h:\\w\\a$PS1” 将PS1那行修改为(其实就是把w换成W) 1PS1&#x3D;”[\\u@\\h:\\W]\\\\$” 添加环境变量1export PATH=$PATH:/home/victorv 创建terminal的快捷键如果是在kali，terminal是没有快捷键的，到设置的keyboard里面，添加自定义快捷键，键值为 1gnome-terminal 或者安装nautilus-open-terminal gdb改变汇编代码显示方式1(gdb) set disas intel 设置反汇编代码使用的指令集，可选择 intel 指令集或 AT&amp;T指令集. usb驱动相关1234567891011121314查找usb驱动$ sudo lspci…02:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168B PCI Express Gigabit Ethernet controller (rev 01)$ find /sys | grep drivers.*02:00获取usb设备信息lsusb -tcat /proc/bus/usb/deviceslshw卸载usb驱动tree /sys/bus/usb/driversecho -n “1-1:1.0” &gt; /sys/bus/usb/drivers/ub/unbind centos安装内核header1yum install kernel-devel-$(uname -r) kernel-headers-$(uname -r) 添加sudoer 并且取消密码12superuser ALL=(ALL) NOPASSWD:ALLsuperuser ALL=(ALL:ALL) ALL #不取消密码 创建ssh服务12345$ yum -y install openssh-server openssh-clients$ chkconfig sshd on$ service sshd start$ netstat -tulpn | grep :22$ vi /etc/sysconfig/iptables -A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT 创建ftp 服务123sudo yum install vsftpdsudo service vsftpd restartchkconfig vsftpd on ubuntu修改内核调试启动项1vi /etc/default/grub 在屁股后面添加 kgdboc=ttyS1,115200 12grep menu /boot/grub/grub.cfggrub-reboot ‘1&gt;3’ 第一个数字1代表第二行的submenu，第二个3代表submenu的第四个（从0开始） 挂起一个进程ctrl+zfg 恢复 打包、解压文件解包使用x,打包使用c tar.xz解包:tar zxvf file.tar.xz 或者:xz -d file.tar.xz &amp;&amp; tar xvf file.tar打包:tar zcvf file.tar.xz .tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）———————————————.gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName .tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName———————————————.bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName———————————————.bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知 .tar.bz解压：tar jxvf FileName.tar.bz压缩：未知———————————————.Z解压：uncompress FileName.Z压缩：compress FileName.tar.Z 解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName———————————————.zip解压：unzip FileName.zip压缩：zip FileName.zip DirName———————————————.rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName———————————————.lha解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName———————————————.rpm解包：rpm2cpio FileName.rpm | cpio -div———————————————.deb解包：ar p FileName.deb data.tar.gz | tar zxf -———————————————.tar .tgz .tar.gz .tar.Z .tar.bz .tar.bz2 .zip .cpio .rpm .deb .slp .arj .rar .ace .lha .lzh .lzx .lzs .arc .sda .sfx .lnx .zoo .cab .kar .cpt .pit .sit .sea解压：sEx x FileName.*压缩：sEx a FileName.* FileName 单独重新编译一个内核模块当我们想修改内核某个模块,又不想重新make all的时候,可以这样操作. 1make drivers&#x2F;net&#x2F;ethernet&#x2F;intel&#x2F;e1000&#x2F;e1000.ko 或者 1make drivers&#x2F;net&#x2F;ethernet&#x2F;intel&#x2F;e1000&#x2F;","categories":[],"tags":[]}],"categories":[],"tags":[]}