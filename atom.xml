<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>VictorV的小博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://474172261.github.io/"/>
  <updated>2020-04-21T03:11:07.872Z</updated>
  <id>http://474172261.github.io/</id>
  
  <author>
    <name>VictorV</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在ESXi中调试运行虚拟机的vmx程序(How to debug vmx in ESXi)</title>
    <link href="http://474172261.github.io/2020/04/21/debug_vmx_in_esxi/"/>
    <id>http://474172261.github.io/2020/04/21/debug_vmx_in_esxi/</id>
    <published>2020-04-21T02:21:48.296Z</published>
    <updated>2020-04-21T03:11:07.872Z</updated>
    
    <content type="html"><![CDATA[<p>ESXi自带一个子linux系统, 虽然能实现一部分功能, 但是目前为止, 依然没有公开的教程说过如何调试vmx进程, 本篇教程将分享我的研究成果, 帮助大家轻松调试虚拟机进程.</p><a id="more"></a><h2 id="最简单的方法"><a href="#最简单的方法" class="headerlink" title="最简单的方法"></a>最简单的方法</h2><p>首先, ESXi 自带一个gdbserver, 所以最简单的方法就是直接跑起程序, 再用gdbserver attach它.</p><ol><li><p>跑起虚拟机, 查看vmx对应的进程id</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@192:~] ps|grep vmx</span><br><span class="line">70639  70639  vmx</span><br><span class="line">70643  70639  vmx-vthread-706</span><br><span class="line">70644  70639  vmx-filtPoll:c7</span><br><span class="line">70645  70639  vmx-mks:c7</span><br><span class="line">70646  70639  vmx-svga:c7</span><br><span class="line">70647  70639  vmx-vcpu-0:c7</span><br></pre></td></tr></table></figure></li><li><p>gdbserver attach 上去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@192:~] gdbserver --attach :8808 70639</span><br><span class="line">Attached; pid = 70639</span><br><span class="line">!gdb_connected()</span><br><span class="line">!gdb_connected()</span><br><span class="line">!gdb_connected()</span><br><span class="line">!gdb_connected()</span><br><span class="line"></span><br><span class="line">[root@192:~] gdbserver --attach :8808 70639</span><br><span class="line">Attached; pid = 70639</span><br><span class="line">!gdb_connected()</span><br><span class="line">Listening on port 8808</span><br></pre></td></tr></table></figure><p>一定要保证出现<code>Listening on port</code>, 不然 ctrl+c 中断, 再重试就好, 目标进程不受影响.</p></li><li><p>找一台可以使用gdb的机器, 把ESXi中的vmx文件拷贝到机器中, 然后使用如下命令连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@192 vv]<span class="comment"># gdb -q</span></span><br><span class="line">gdb$ file Desktop/vmx-7.0-15843807.elf </span><br><span class="line">Reading symbols from /home/vv/Desktop/vmx-7.0-15843807.elf...Missing separate debuginfo <span class="keyword">for</span> /home/vv/Desktop/vmx-7.0-15843807.elf</span><br><span class="line">(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">gdb$ target remote 192.168.170.240:8808</span><br><span class="line">Remote debugging using 192.168.170.240:8808</span><br><span class="line">=&gt; 0x8ce2771248 &lt;__libc_ifunc_impl_list+3304&gt;:cmp    rax,0xfffffffffffff000</span><br><span class="line">   0x8ce277124e &lt;__libc_ifunc_impl_list+3310&gt;:ja     0x8ce2771275 &lt;__libc_ifunc_impl_list+3349&gt;</span><br><span class="line"></span><br><span class="line">gdb$</span><br></pre></td></tr></table></figure><p>这样就可以正常调试了</p></li></ol><h2 id="不那么简单的办法"><a href="#不那么简单的办法" class="headerlink" title="不那么简单的办法"></a>不那么简单的办法</h2><p>如果自带的gdbserver 不太好用, 那也可以自己源码静态编译一个gdb版本拷贝过去, 然后直接用.</p><ol><li>自己源码编译一个gdb, 或者用我编译好的<a href="/otherfile/gdb7_8.xz">gdb</a>, 拷贝到esxi上</li><li>运行起虚拟机</li><li>运行gdb, 一般会告诉你缺失libtinfo.so.5文件或者libncurses.so.5, 最简单的方法就是创建一个软链接, 把它自带的一个文件软链接成确实的文件.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@192:~] ln -s /lib64/libncurses.so.5 /lib64/libtinfo.so.5</span><br></pre></td></tr></table></figure>或者从centos 7 3.10内核的系统中拷贝一个过去放在lib64目录下.</li><li>使用gdb调试<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb$ file /bin/vmx</span><br><span class="line">gdb$ <span class="built_in">set</span> architecture i386:x86-64:intel</span><br><span class="line">gdb$ attach xxxxx</span><br></pre></td></tr></table></figure></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果发现ctrl+c不好使, 那么就把虚拟机的cpu个数设置为1. 如果还是不好使, 建议重新选个guest安装测试.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ESXi自带一个子linux系统, 虽然能实现一部分功能, 但是目前为止, 依然没有公开的教程说过如何调试vmx进程, 本篇教程将分享我的研究成果, 帮助大家轻松调试虚拟机进程.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>说我之前的leader 唐青昊, 也是第一次见识到的这样卑鄙的人</title>
    <link href="http://474172261.github.io/2020/03/29/fuck_tqh/"/>
    <id>http://474172261.github.io/2020/03/29/fuck_tqh/</id>
    <published>2020-03-29T07:15:15.805Z</published>
    <updated>2020-03-29T10:19:26.380Z</updated>
    
    <content type="html"><![CDATA[<p>一直懒得吐槽<a href="https://cn.linkedin.com/in/%E9%9D%92%E6%98%8A-%E5%94%90-1b78229b" target="_blank" rel="noopener">唐青昊</a>🖕，毕竟遇到糟糕的leader大不了走人，但是有些东西会随着时间忘记，导致后来的人继续掉坑里。所以还是发个文，曝光一下这个人，让大家认清这个人，不要被他简历上的”成就”蒙蔽了双眼。</p><a id="more"></a><p>本来这个帖子是发到看雪的, 一开始还正常, 后来版主把帖子移到比较私密的会员区了, 背离了我让大家避坑的初衷, 没办法, 重新把blog整起来, 帮助大家看清楚这个人。 </p><p>一搜他，网上也是有不少的资料，我这个故事呢，从他带领 360 的marvel团队那年开始(他已经不在360了)。一部分内容是听说的，但是也基本上没假的。（该团队在核心大牛走得差不多后就解散了，他跳槽离开的时候还没有解散，只剩下开发团队的人，后来才算真解散了）</p><h2 id="首先，第一个要说的就是有他名字的cve号"><a href="#首先，第一个要说的就是有他名字的cve号" class="headerlink" title="首先，第一个要说的就是有他名字的cve号"></a>首先，第一个要说的就是有他名字的cve号</h2><p>qemu的多个cve号里，虽然有他名字，但是<strong>都和他无关</strong>，都是团队里的其它成员发现的。只不过他仗着自己是leader， 用自己的名义去提交给官方，所以cve的公开信息里只有他的名字，真的发现者的名字却没有。当然就算有怨气，人在屋檐下，其他人也没办法。</p><h2 id="第二个就是关于他的那些虚拟化逃逸的技术演讲"><a href="#第二个就是关于他的那些虚拟化逃逸的技术演讲" class="headerlink" title="第二个就是关于他的那些虚拟化逃逸的技术演讲"></a>第二个就是关于他的那些虚拟化逃逸的技术演讲</h2><p>无论是讲<strong>qemu的逃逸</strong>[1]，还是<strong>vmware workstation的逃逸</strong>[2]，技术上都和他没有一点关系。强行利用自己leader身份凑一起出去演讲，对外塑造一副自己是发现者的形象，着实卑劣。另外他要求技术大牛给他讲workstation逃逸的利用细节，本来是别人发现的利用技术，他就想占位己有，把要来的大牛的利用exp自己改个格式，写个注释，对外当作是自己写出来的样子。</p><h2 id="第三个就是出书了"><a href="#第三个就是出书了" class="headerlink" title="第三个就是出书了"></a>第三个就是出书了</h2><p>他的那本<a href="http://www.baike.com/wiki/%E4%BA%91%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E8%B7%B5" target="_blank" rel="noopener">《云虚拟化安全攻防实践》</a>书，本来是团队凑一起写了出书，收益大家均分，这个当时都有一个临时协议纸条， 大家都有签名。后来因为核心技术研究员都被逼走了，他就说要不大家把书出完吧。本来有始有终对大家都好，但是他耍心眼，不肯把整书拿出来让大家看，还私下找一些参与者说一起出书，把其他人忽略掉，最后可能有人不同意所以被迫听取一下大家意见。鉴于他的无耻，我也就没同意把我写的那部分发布在书里，当然其它几个成员也没同意。</p><p>但是最后他还是无耻地把书给出了，还把我和其它几个技术成员的内容改得面目全非。对比他的书和我发布的帖子<a href="https://bbs.pediy.com/thread-224371.htm" target="_blank" rel="noopener">“QEMU 与 KVM 虚拟化安全研究介绍”</a>以及看雪关于hyper-v的帖子<a href="https://bbs.pediy.com/thread-222626.htm" target="_blank" rel="noopener">Hyper-V安全从0到1(1)</a>，就知道他盗用了多少，改得多烂。另外, <strong>真正由他写的内容也就第一章</strong>, 由于版权原因, 他就更换了一些内容, 把其它人给他的分析报告, 修修改改写进书里了。</p><h2 id="第四个他偷偷报大牛的洞"><a href="#第四个他偷偷报大牛的洞" class="headerlink" title="第四个他偷偷报大牛的洞"></a>第四个他偷偷报大牛的洞</h2><p>在团队技术大牛已经走了的情况下，他偷偷把大牛没有上报的bug报了领取奖励，这事不是一般的下流。而且干了不止一次。</p><h2 id="最后呢"><a href="#最后呢" class="headerlink" title="最后呢"></a>最后呢</h2><p>这些都是旧事了，但是萌新可能不知道，一些想邀请他的人也不知道，写个帖子，留作记录，给大家避坑。</p><p>其它关于他为人处事的故事我不必多说，坊间都有”佳话”，至于事实证明，可以问当事人，想必你肯定可以听到更有意思的故事(❛ᴗ❛)</p><p><strong>还有件事就是，任何时候，都不要把自己的办公电脑密码给别人，除非你很信得过那个人！！！</strong></p><p>我当时因为不想跟着这混蛋，又因为一些其它原因，就没有换团队，而是打算离开360。17年7月的时候毕业了，准备回去办离职，忘了因为什么事情（好像是我需要远程登录吧），就让他帮我登录了下我的办公电脑。后来我怕他乱动我的文件，就给一些文件加密了，因为远程vpn连接不方便直接改密码，所以没改。后来准备办离职，需要登录，结果我的密码被他改了，他还不肯告诉我，说怕我泄露公司机密。excuse me？？我自己的办公电脑，有啥我自己不能看的？我都还没有办离职，看自己电脑怎么了？</p><p>其实就是他想偷看我的文件，结果发现我加密了文件，所以他就把我密码改了（这个不是猜的，他说的）。搞得我没办法正常离职，后来不了了之（因为是实习，实习协议也到期了，我也给了我该给的交接文件）。</p><p>这件事我只能说是我自己太单纯，写出来也是给萌新提个醒，不要轻易信任别人而给出你的密码。</p><h2 id="相关技术演讲"><a href="#相关技术演讲" class="headerlink" title="相关技术演讲"></a>相关技术演讲</h2><p>[1] Wei Xiao, Qinghao Tang, “qemu+kvm &amp; xen pwn: virtual machine escape from ‘Dark Portal’”</p><p>[2] CSW2017 Qinghao tang+Xinlei ying vmware_escape_final</p><h2 id="方便大家吃瓜-给个对比图"><a href="#方便大家吃瓜-给个对比图" class="headerlink" title="方便大家吃瓜, 给个对比图"></a>方便大家吃瓜, 给个对比图</h2><p><img src="/images/fuck_tqh/fuck_tqh.jpg" alt="t1"></p><h2 id="贴下之前的评论"><a href="#贴下之前的评论" class="headerlink" title="贴下之前的评论"></a>贴下之前的评论</h2><p><img src="/images/fuck_tqh/bianshi.png" alt="t2"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直懒得吐槽&lt;a href=&quot;https://cn.linkedin.com/in/%E9%9D%92%E6%98%8A-%E5%94%90-1b78229b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;唐青昊&lt;/a&gt;🖕，毕竟遇到糟糕的leader大不了走人，但是有些东西会随着时间忘记，导致后来的人继续掉坑里。所以还是发个文，曝光一下这个人，让大家认清这个人，不要被他简历上的”成就”蒙蔽了双眼。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linux 内核和用户态通信之 /proc文件系统</title>
    <link href="http://474172261.github.io/2020/03/29/linux-proc/"/>
    <id>http://474172261.github.io/2020/03/29/linux-proc/</id>
    <published>2020-03-29T07:00:54.368Z</published>
    <updated>2020-03-29T10:19:39.093Z</updated>
    
    <content type="html"><![CDATA[<p>/proc 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在 Linux® 内核空间和用户空间之间进行通信。在 /proc 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的.</p><a id="more"></a><p>/proc 文件系统包含了一些目录（用作组织信息的方式）和虚拟文件。虚拟文件可以向用户呈现内核中的一些信息，也可以用作一种从用户空间向内核发送信息的手段。</p><h2 id="创建一个-proc文件"><a href="#创建一个-proc文件" class="headerlink" title="创建一个/proc文件"></a>创建一个/proc文件</h2><p>在3.8内核之前,使用create_proc_entry创建一个文件,原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct proc_dir_entry *<span class="title">create_proc_entry</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">mode_t</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             struct proc_dir_entry *parent )</span></span>;<span class="comment">//创建一个虚拟文件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;     <span class="comment">// 节点名称</span></span><br><span class="line">  <span class="keyword">mode_t</span> mode;        <span class="comment">// 权限,与chmod的一样,可以使用八进制表示</span></span><br><span class="line">  <span class="keyword">uid_t</span> uid;        <span class="comment">// File's user id</span></span><br><span class="line">  <span class="keyword">gid_t</span> gid;        <span class="comment">// File's group id</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> *<span class="title">proc_iops</span>;</span> <span class="comment">// 索引节点操作函数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span>  <span class="comment">// 文件操作函数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">parent</span>;</span>    <span class="comment">// 父目录,如果是NULL,就代表/proc目录</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">read_proc_t</span> *read_proc;     <span class="comment">// 输出给cat的函数</span></span><br><span class="line">  <span class="keyword">write_proc_t</span> *write_proc;   <span class="comment">// 读取用户输入的函数</span></span><br><span class="line">  <span class="keyword">void</span> *data;       <span class="comment">// 指向private 数据</span></span><br><span class="line">  <span class="keyword">atomic_t</span> count;       <span class="comment">// 使用计数</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_proc_entry</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name, struct proc_dir_entry *parent )</span></span>;<span class="comment">//不仅可以删除节点,还能删除proc_mkdir创建的目录</span></span><br><span class="line"><span class="function">struct proc_dir_entry *<span class="title">proc_mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct proc_dir_entry *parent)</span></span>;  <span class="comment">//创建一个虚拟目录</span></span><br></pre></td></tr></table></figure><p>parent 参数可以为 NULL（表示 /proc 根目录），也可以是很多其他值</p><table><thead><tr><th>proc_dir_entry</th><th>在文件系统中的位置</th></tr></thead><tbody><tr><td>proc_root_fs</td><td>/proc</td></tr><tr><td>proc_net</td><td>/proc/net</td></tr><tr><td>proc_bus</td><td>/proc/bus</td></tr><tr><td>proc_root_driver</td><td>/proc/driver</td></tr></tbody></table><p>如果我们想创建一个文件为test_modul的虚拟文件,就这样初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create_proc_entry( <span class="string">"test_module"</span>, <span class="number">0644</span>, <span class="literal">NULL</span> );</span><br><span class="line">或者</span><br><span class="line">pt_root = proc_mkdir(<span class="string">"test_menu"</span>, <span class="literal">NULL</span>);</span><br><span class="line">pt_entry1 = create_proc_entry(USER_ENTRY1, <span class="number">0666</span>, pt_root);</span><br></pre></td></tr></table></figure><h2 id="proc文件交互函数"><a href="#proc文件交互函数" class="headerlink" title="/proc文件交互函数"></a>/proc文件交互函数</h2><p><strong>read_proc</strong> 供用户读取的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_read</span><span class="params">( <span class="keyword">char</span> *page,<span class="comment">//数据写入的位置,该page缓冲区在内核</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span> **start,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">off_t</span> off,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> count,<span class="comment">//定义写入的最大字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> *eof, <span class="comment">//当数据写入完后,需要设置为1</span></span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">void</span> *data <span class="comment">//private 数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">              )</span></span>;</span><br></pre></td></tr></table></figure><p>当需要写入多页数据时(一般一页4Kb),需要用到 start,off.</p><p><strong>write_proc</strong> 读取用户的输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_write</span><span class="params">( struct file *filp, <span class="comment">//指向一个打开的文件结构</span></span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">const</span> <span class="keyword">char</span> __user *buff, <span class="comment">//用户输入的数据,buff在用户空间,内核要读取需要用到copy_from_user</span></span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="comment">//长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> *data </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>其它需要用到的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个符号链接 */</span></span><br><span class="line"><span class="function">struct proc_dir_entry *<span class="title">proc_symlink</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       struct proc_dir_entry *parent,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> <span class="keyword">char</span> *dest )</span></span>;</span><br><span class="line"><span class="comment">/* Create a proc_dir_entry with a read_proc_t in one call */</span></span><br><span class="line"><span class="function">struct proc_dir_entry *<span class="title">create_proc_read_entry</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">mode_t</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  struct proc_dir_entry *base,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">read_proc_t</span> *read_proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">void</span> *data )</span></span>;</span><br><span class="line"><span class="comment">/* 从内核空间复制数据到用户空间 */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">copy_to_user</span><span class="params">( <span class="keyword">void</span> __user *to,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> <span class="keyword">void</span> *from,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">unsigned</span> <span class="keyword">long</span> n )</span></span>;</span><br><span class="line"><span class="comment">/* 从用户空间到内核 */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">copy_from_user</span><span class="params">( <span class="keyword">void</span> *to,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">void</span> __user *from,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">unsigned</span> <span class="keyword">long</span> n )</span></span>;</span><br><span class="line"><span class="comment">/* 创建虚拟的连续内存块 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">vmalloc</span><span class="params">( <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span> )</span></span>;</span><br><span class="line"><span class="comment">/* 释放vmalloc创建的块 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfree</span><span class="params">( <span class="keyword">void</span> *addr )</span></span>;</span><br><span class="line"><span class="comment">/* Export a symbol to the kernel (make it visible to the kernel) */</span></span><br><span class="line">EXPORT_SYMBOL( symbol );</span><br><span class="line"><span class="comment">/* Export all symbols in a file to the kernel (declare before module.h) */</span></span><br><span class="line">EXPORT_SYMTAB</span><br></pre></td></tr></table></figure><h2 id="创建内核驱动"><a href="#创建内核驱动" class="headerlink" title="创建内核驱动"></a>创建内核驱动</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Defines the license for this LKM */</span></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_module_init</span><span class="params">( <span class="keyword">void</span> )</span><span class="comment">//自定义的初始化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  printk(KERN_INFO <span class="string">"my_module_init called.  Module is now loaded.\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_module_cleanup</span><span class="params">( <span class="keyword">void</span> )</span><span class="comment">//自定义的退出函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  printk(KERN_INFO <span class="string">"my_module_cleanup called.  Module is now unloaded.\n"</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init( my_module_init );<span class="comment">//声明初始化函数</span></span><br><span class="line">module_exit( my_module_cleanup );<span class="comment">//声明退出函数</span></span><br></pre></td></tr></table></figure><blockquote><p>从3.10内核开始,create_proc_entry() 函数被替换成proc_create() 函数<br>函数区别如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proc_file = create_proc_entry(<span class="string">"file"</span>,<span class="number">0600</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (proc_file) &#123;</span><br><span class="line">       proc_file-&gt;read_proc = file_read;  </span><br><span class="line">       proc_file-&gt;write_proc = file_write;</span><br><span class="line">       proc_file-&gt;owner = THIS_MODULE;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></blockquote><h2 id="编译安装驱动"><a href="#编译安装驱动" class="headerlink" title="编译安装驱动"></a>编译安装驱动</h2><p>Makefile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m +&#x3D; simple-km.o</span><br><span class="line"></span><br><span class="line">all:    </span><br><span class="line">make -C &#x2F;lib&#x2F;modules&#x2F;&#96;uname -r&#96;&#x2F;build SUBDIRS&#x3D;$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:  </span><br><span class="line">make -C &#x2F;lib&#x2F;modules&#x2F;&#96;uname -r&#96;&#x2F;build SUBDIRS&#x3D;$(PWD) modules</span><br></pre></td></tr></table></figure><blockquote><p>开头的是tab, 不是空格, 一定要注意</p></blockquote><p>执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ insmod simple-km.ko </span><br><span class="line">$ dmesg | tail -5      查看最后5行信息</span><br><span class="line">$ lsmod</span><br><span class="line">$ rmmod simple-km.ko</span><br></pre></td></tr></table></figure><h2 id="一个简单的示例"><a href="#一个简单的示例" class="headerlink" title="一个简单的示例"></a>一个简单的示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/vmalloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Fortune Cookie Kernel Module"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"VictorV"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_COOKIE_LENGTH       PAGE_SIZE</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_entry</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *cookie_pot;  <span class="comment">// 内存缓冲区</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cookie_index;  <span class="comment">// 指向缓冲区的数据尾部</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> next_fortune;  <span class="comment">// 通过\0分开字符串,此处用来指向下一个需要输出的缓冲字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">fortune_write</span><span class="params">( struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">char</span> __user *buff,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">unsigned</span> <span class="keyword">long</span> len, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> *data )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> space_available = (MAX_COOKIE_LENGTH-cookie_index)+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (len &gt; space_available) &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"fortune: cookie pot is full!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (copy_from_user( &amp;cookie_pot[cookie_index], buff, len )) &#123;</span><br><span class="line">  <span class="comment">//从用户空间读取数据到cookie_pot,</span></span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">  &#125;</span><br><span class="line">  cookie_index += len;</span><br><span class="line">  cookie_pot[cookie_index<span class="number">-1</span>] = <span class="number">0</span>;<span class="comment">//将最后一位置零</span></span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fortune_read</span><span class="params">( <span class="keyword">char</span> *page, <span class="keyword">char</span> **start, <span class="keyword">off_t</span> off,<span class="keyword">int</span> count, <span class="keyword">int</span> *eof, <span class="keyword">void</span> *data )</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">if</span> (off &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    *eof = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (next_fortune &gt;= cookie_index) next_fortune = <span class="number">0</span>;<span class="comment">//超过数据个数,就循环读取</span></span><br><span class="line">  len = <span class="built_in">sprintf</span>(page, <span class="string">"%s\n"</span>, &amp;cookie_pot[next_fortune]);<span class="comment">//将一段字符串写入page</span></span><br><span class="line">  next_fortune += len;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_fortune_module</span><span class="params">( <span class="keyword">void</span> )</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  cookie_pot = (<span class="keyword">char</span> *)vmalloc( MAX_COOKIE_LENGTH );<span class="comment">//申请一段内核空间</span></span><br><span class="line">  <span class="keyword">if</span> (!cookie_pot) &#123;</span><br><span class="line">    ret = -ENOMEM;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>( cookie_pot, <span class="number">0</span>, MAX_COOKIE_LENGTH );</span><br><span class="line">    proc_entry = create_proc_entry( <span class="string">"fortune"</span>, <span class="number">0644</span>, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="keyword">if</span> (proc_entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ret = -ENOMEM;</span><br><span class="line">      vfree(cookie_pot);</span><br><span class="line">      printk(KERN_INFO <span class="string">"fortune: Couldn't create proc entry\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cookie_index = <span class="number">0</span>;</span><br><span class="line">      next_fortune = <span class="number">0</span>;</span><br><span class="line">      proc_entry-&gt;read_proc = fortune_read;<span class="comment">//这里定义输出函数</span></span><br><span class="line">      proc_entry-&gt;write_proc = fortune_write;<span class="comment">//定义输入函数</span></span><br><span class="line">      proc_entry-&gt;owner = THIS_MODULE;</span><br><span class="line">      printk(KERN_INFO <span class="string">"fortune: Module loaded.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup_fortune_module</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  remove_proc_entry(<span class="string">"fortune"</span>, &amp;proc_root);</span><br><span class="line">  vfree(cookie_pot);</span><br><span class="line">  printk(KERN_INFO <span class="string">"fortune: Module unloaded.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init( init_fortune_module );</span><br><span class="line">module_exit( cleanup_fortune_module );</span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@plato]<span class="comment"># insmod fortune.ko</span></span><br><span class="line">[root@plato]<span class="comment"># echo "Success is an individual proposition.  </span></span><br><span class="line">          Thomas Watson<span class="string">" &gt; /proc/fortune</span></span><br><span class="line"><span class="string">[root@plato]# echo "</span>If a man does his best, what <span class="keyword">else</span> is there?  </span><br><span class="line">                Gen. Patton<span class="string">" &gt; /proc/fortune</span></span><br><span class="line"><span class="string">[root@plato]# echo "</span>Cats: All your base are belong to us.  </span><br><span class="line">                      Zero Wing<span class="string">" &gt; /proc/fortune</span></span><br><span class="line"><span class="string">[root@plato]# cat /proc/fortune</span></span><br><span class="line"><span class="string">Success is an individual proposition.  Thomas Watson</span></span><br><span class="line"><span class="string">[root@plato]# cat /proc/fortune</span></span><br><span class="line"><span class="string">If a man does his best, what else is there?  General Patton</span></span><br><span class="line"><span class="string">[root@plato]#</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;/proc 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在 Linux® 内核空间和用户空间之间进行通信。在 /proc 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>windows 内核调试配置</title>
    <link href="http://474172261.github.io/2020/03/29/windows-debug-setting/"/>
    <id>http://474172261.github.io/2020/03/29/windows-debug-setting/</id>
    <published>2020-03-29T06:43:22.521Z</published>
    <updated>2020-03-29T10:16:20.967Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="添加串口到虚拟机"><a href="#添加串口到虚拟机" class="headerlink" title="添加串口到虚拟机"></a>添加串口到虚拟机</h2><p>安装好虚拟机后, 添加串口设配, 配置如下<br><img src="/images/windows-setting/2.png" alt=""></p><h2 id="配置虚拟机windows系统-简称Guest"><a href="#配置虚拟机windows系统-简称Guest" class="headerlink" title="配置虚拟机windows系统(简称Guest)"></a>配置虚拟机windows系统(简称Guest)</h2><p>按组合键win+r, 输入 msconfig.做如下配置<br><img src="/images/windows-setting/3.png" alt=""><br>重启虚拟机</p><h2 id="配置外部主机-检查Host"><a href="#配置外部主机-检查Host" class="headerlink" title="配置外部主机(检查Host)"></a>配置外部主机(检查Host)</h2><p>找到windbg的快捷方式, 右键属性, 添加参数<code>-b -k com:port=\\.\pipe\com_1,baud=115200,pipe”</code><br><img src="/images/windows-setting/4.png" alt=""></p><h2 id="连接调试器"><a href="#连接调试器" class="headerlink" title="连接调试器"></a>连接调试器</h2><p>在Guest启动后, 在Host打开刚才设置的windbg快捷方式, 如下便连接成功<br><img src="/images/windows-setting/5.png" alt=""></p><h2 id="添加符号"><a href="#添加符号" class="headerlink" title="添加符号"></a>添加符号</h2><p><img src="/images/windows-setting/6.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;添加串口到虚拟机&quot;&gt;&lt;a href=&quot;#添加串口到虚拟机&quot; class=&quot;headerlink&quot; title=&quot;添加串口到虚拟机&quot;&gt;&lt;/a&gt;添加串口到虚拟机&lt;/h2&gt;&lt;p&gt;安装好虚拟机后, 添加串口设配, 配置如下&lt;br&gt;&lt;i
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux双虚拟机调试</title>
    <link href="http://474172261.github.io/2020/03/29/linux-debug-setting/"/>
    <id>http://474172261.github.io/2020/03/29/linux-debug-setting/</id>
    <published>2020-03-29T06:22:04.760Z</published>
    <updated>2020-03-29T10:19:44.776Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="准备内核"><a href="#准备内核" class="headerlink" title="准备内核"></a>准备内核</h2><p><a href="https://www.kernel.org/pub/linux/kernel/" target="_blank" rel="noopener">linux kernel source</a></p><h2 id="配置虚拟机"><a href="#配置虚拟机" class="headerlink" title="配置虚拟机"></a>配置虚拟机</h2><ol><li>新建一个虚拟机</li><li>添加串口, 并做如下配置<br><img src="/images/linux-setting/1.png" alt=""><br>此虚拟机作为被调试机</li></ol><h2 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h2><p><img src="/images/linux-setting/3.png" alt=""></p><p>修改串口设备的配置,设定为”该端为客户端”, 此为调试机</p><h2 id="在被调试机编译内核"><a href="#在被调试机编译内核" class="headerlink" title="在被调试机编译内核"></a>在被调试机编译内核</h2><ol><li><p>解压内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar jxvf linux-2.6.26.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> linux-*</span><br></pre></td></tr></table></figure></li><li><p>配置编译参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><blockquote><p><strong>可能的错误</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error: curses.h: No such file or directory</span><br><span class="line">基于Debian的发行版（如Debian、Ubuntu）：sudo apt-get install libncurses5-dev</span><br><span class="line">基于Red Hat的发行版（如RHEL、CentOS）：sudo yum install ncurses-devel</span><br><span class="line"></span><br><span class="line">如果出现找不到该包，尝试以下设置：</span><br><span class="line">vi  &#x2F;etc&#x2F;apt&#x2F;source.list</span><br><span class="line">添加其它系统的源[源列表地址](http:&#x2F;&#x2F;mirrors.163.com&#x2F;.help&#x2F;debian.html)</span><br><span class="line">比如kali,我添加的debian jessie的源</span><br></pre></td></tr></table></figure><p>如果提示窗口太小出错,说明你的命令行窗口小了,放大一点再试试.<br>内核调试需要做如下设置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Kernel Hacking –&gt;</span><br><span class="line">   compile-time checks and compiler options –&gt;</span><br><span class="line">       [*] Compile the kernel with debug info</span><br><span class="line">       [*] Compile the kernel with frame pointers</span><br><span class="line">   [*] kernel debugging</span><br><span class="line">   [*] KGDB: kernel debugger–&gt;</span><br><span class="line">       &lt;*&gt; KGDB: use kgdb over the serial console</span><br></pre></td></tr></table></figure><p>完成上述选项后, 直接save后推出.</p></li><li><p>编译内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make -j 4 bzImage <span class="comment"># -j 代表用多少线程, 不要超过cpu的最大线程数</span></span><br><span class="line">make modules</span><br><span class="line">make modules_install</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>修改启动表<br>打开 /boot/grub/grub.conf (如果不存在, 就改grub.cfg文件)<br>针对 grub.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 1 # grub.conf generated by anaconda</span><br><span class="line"> 2 #</span><br><span class="line"> 3 # Note that you do not have to rerun grub after making changes to this file</span><br><span class="line"> 4 # NOTICE:  You have a &#x2F;boot partition.  This means that</span><br><span class="line"> 5 #          all kernel and initrd paths are relative to &#x2F;boot&#x2F;, eg.</span><br><span class="line"> 6 #          root (hd0,0)</span><br><span class="line"> 7 #          kernel &#x2F;vmlinuz-version ro root&#x3D;&#x2F;dev&#x2F;VolGroup00&#x2F;LogVol00</span><br><span class="line"> 8 #          initrd &#x2F;initrd-version.img</span><br><span class="line"> 9 #boot&#x3D;&#x2F;dev&#x2F;hda</span><br><span class="line">10 default&#x3D;0</span><br><span class="line">11 timeout&#x3D;5</span><br><span class="line">12 splashimage&#x3D;(hd0,0)&#x2F;grub&#x2F;splash.xpm.gz</span><br><span class="line">13 hiddenmenu</span><br><span class="line">14 title CentOS (2.6.26)</span><br><span class="line">15     root (hd0,0)</span><br><span class="line">16     kernel &#x2F;vmlinuz-2.6.26 ro root&#x3D;&#x2F;dev&#x2F;VolGroup00&#x2F;LogVol00   </span><br><span class="line">17     initrd &#x2F;initrd-2.6.26.img</span><br><span class="line">18 title CentOS-4 i386 (2.6.9-67.ELsmp)</span><br><span class="line">19     root (hd0,0)</span><br><span class="line">20     kernel &#x2F;vmlinuz-2.6.9-67.ELsmp ro root&#x3D;&#x2F;dev&#x2F;VolGroup00&#x2F;LogVol00   &lt;---------------------</span><br><span class="line">21     initrd &#x2F;initrd-2.6.9-67.ELsmp.img</span><br></pre></td></tr></table></figure><p>在kernel那一行末尾添加 “kgdboc=ttyS0,115200”<br>如下图:<br><img src="/images/linux-setting/2.png" alt=""><br>针对 grub.cfg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">menuentry &#39;Ubuntu, with Linux 3.8.0-19-generic&#39; --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option &#39;gnulinux-3.8.0-19-generic-advanced-af5e68c6-4f1f-494e-8c35-fc0911ec3564&#39; &#123;</span><br><span class="line">recordfail</span><br><span class="line">  load_video</span><br><span class="line">  gfxmode $linux_gfx_mode</span><br><span class="line">  insmod gzio</span><br><span class="line">  insmod part_msdos</span><br><span class="line">  insmod ext2</span><br><span class="line">  set root&#x3D;&#39;hd0,msdos1&#39;</span><br><span class="line">  if [ x$feature_platform_search_hint &#x3D; xy ]; then</span><br><span class="line">    search --no-floppy --fs-uuid --set&#x3D;root --hint-bios&#x3D;hd0,msdos1 --hint-efi&#x3D;hd0,msdos1 --hint-baremetal&#x3D;ahci0,msdos1  af5e68c6-4f1f-494e-8c35-fc0911ec3564</span><br><span class="line">  else</span><br><span class="line">    search --no-floppy --fs-uuid --set&#x3D;root af5e68c6-4f1f-494e-8c35-fc0911ec3564</span><br><span class="line">  fi</span><br><span class="line">  echo  &#39;Loading Linux 3.8.0-19-generic ...&#39;</span><br><span class="line">  linux &#x2F;boot&#x2F;vmlinuz-3.8.0-19-generic root&#x3D;UUID&#x3D;af5e68c6-4f1f-494e-8c35-fc0911ec3564 ro find_preseed&#x3D;&#x2F;preseed.cfg auto noprompt priority&#x3D;critical locale&#x3D;en_US  kgdboc&#x3D;ttyS0,115200  kgdbwait  quiet </span><br><span class="line">  ^</span><br><span class="line">  |</span><br><span class="line">  -------------</span><br><span class="line">  echo  &#39;Loading initial ramdisk ...&#39;</span><br><span class="line">  initrd  &#x2F;boot&#x2F;initrd.img-3.8.0-19-generic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在新内核对应的内容下添加 “kgdboc=ttyS0,115200”</p></li></ol><h2 id="测试双机调试"><a href="#测试双机调试" class="headerlink" title="测试双机调试"></a>测试双机调试</h2><p>开启两个虚拟机, 在被调试机上运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello &gt;/dev/ttyS0</span><br></pre></td></tr></table></figure><p>在调试机上运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/ttyS0</span><br></pre></td></tr></table></figure><p>如果调试机没有收到消息, 就实时用/dev/ttyS1, 多试两下就行<br>如果成功了, 记得改grub的配置.</p><h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><p>如果grub没有配置”kgdbwait”参数, 就在被调试机开机后输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> g &gt;/proc/sysrq-tirgger</span><br></pre></td></tr></table></figure><p>在调试机里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ gdb linux-3.18.34&#x2F;vmlinux</span><br><span class="line">.....</span><br><span class="line">(gdb) set remotebaud 115200</span><br><span class="line">(gdb) target remote &#x2F;dev&#x2F;ttyS0</span><br><span class="line"></span><br><span class="line">Remote debugging using &#x2F;dev&#x2F;ttyS0</span><br><span class="line">kgdb_breakpoint () at kernel&#x2F;kgdb.c:1674</span><br><span class="line">1674    wmb(); &#x2F;*Sync point after breakpoint *&#x2F;</span><br><span class="line">warning: shared library handler failed to enable breakpoint</span><br><span class="line"></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><blockquote><p>如果”set remotebaud 115200”的时候出错,就换成”set serial baud 115200”</p></blockquote><h2 id="调试自定义驱动"><a href="#调试自定义驱动" class="headerlink" title="调试自定义驱动"></a>调试自定义驱动</h2><p>有空再说吧.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;


&lt;h2 id=&quot;准备内核&quot;&gt;&lt;a href=&quot;#准备内核&quot; class=&quot;headerlink&quot; title=&quot;准备内核&quot;&gt;&lt;/a&gt;准备内核&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.kernel.org/pub/linux/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用github搭建自己的博客</title>
    <link href="http://474172261.github.io/2020/03/29/build-blog/"/>
    <id>http://474172261.github.io/2020/03/29/build-blog/</id>
    <published>2020-03-29T03:25:13.016Z</published>
    <updated>2020-04-13T06:41:53.202Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>首先你需要在github创建一个仓储<br><img src="/images/build-blog/create_git_respository.png" alt="ii1"></p><h2 id="安装git-npm"><a href="#安装git-npm" class="headerlink" title="安装git,npm"></a>安装git,npm</h2><p><strong>windows</strong><br>下载<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node.js</a><br>下载<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save  (或者npm install hexo-cli -g)</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init MYBLOG</span><br><span class="line">cd MYBLOG</span><br></pre></td></tr></table></figure><p>“MYBLOG”是目录名称</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>浏览器访问<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><h2 id="添加主题"><a href="#添加主题" class="headerlink" title="添加主题"></a>添加主题</h2><p>访问<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题库</a>添加主题, 我比较喜欢<a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="noopener">Apollo</a> 不过不更新了, 暂时用 next 主题.</p><h2 id="配置github推送"><a href="#配置github推送" class="headerlink" title="配置github推送"></a>配置github推送</h2><p>获取链接<br><img src="/images/build-blog/get_git.png" alt=""><br>修改MYBLOG/_config.yml文件<br><img src="/images/build-blog/config_git.png" alt=""></p><h2 id="创建sshkey"><a href="#创建sshkey" class="headerlink" title="创建sshkey"></a>创建sshkey</h2><p>在git-bash里面使用如下指令（通过在Hexo文件夹右键选择 “Git bash here”打开）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;邮件地址@youremail.com&quot;</span><br></pre></td></tr></table></figure><p>然后根据提示enter就好(注意文件保存的位置！！)</p><p>登录github, 在Account Settings—&gt;SSH Public keys —&gt; add another public keys中添加你的sshkey.pub文件的内容<br><img src="/images/build-blog/fill_rsa.png" alt=""></p><p>测试key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="/images/build-blog/ssh_link_test.png" alt=""></p><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n <span class="string">"网站标题"</span></span><br></pre></td></tr></table></figure><p>文章文件在Hexo\source_posts里面，后缀为md<br>这是一个markdown文件，具体语法查看markdown语法</p><p>文章内容：</p><blockquote><p>title: 文章名<br>date: 2013-05-29 07:56:29 #发表日期<br>updated: 2016-04-06 14:58:03 #更新日期<br>categories: Life #文章分类<br>description: 你对本页的描述<br>tags: [tag1,tag2] #文章标签. 多标签时使用英文逗号隔开<br>photos: #如果使用Fancybox（文章头部展示图片）. 如此设置</p><p>URL1<br>URL2<br>#从这里开始</p><p>#就是正文</p><p>#使用markdown</p></blockquote><h2 id="推送文章"><a href="#推送文章" class="headerlink" title="推送文章"></a>推送文章</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><blockquote><p>d 是deploy缩写</p></blockquote><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><ol><li>申请域名</li><li>添加选项<br><img src="/images/build-blog/domain_set.png" alt=""></li><li>在github项目根目录添加CNAME文件, 内容为你的域名(比如 xxx.com)</li><li>进入github setting查看<br><img src="/images/build-blog/git_setting.png" alt=""><br>往下拉, 出现如下结果就成功了<br><img src="/images/build-blog/link_success.png" alt=""></li></ol><h2 id="在文章中添加图片"><a href="#在文章中添加图片" class="headerlink" title="在文章中添加图片"></a>在文章中添加图片</h2><p>第一种: 是在MYBLOG\source目录下的images目录里添加图片, 这样在首页也能引用<br>比如文件结构如下:</p><p>MYBLOG\source\<br>images<br>├── b.jpg<br>a.jpg</p><p>使用![ii1](/a.jpg), ![ii2](/images/b.jpg)引用即可</p><p>第二种: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>假设MYBLOG\source\_posts里面的结构如下:<br>firstblog<br>├── apppicker.jpg<br>├── logo.jpg<br>└── rules.jpg<br>firstblog.md<br>目录名必须与md文件名一致, 使用 ![](firstblog/logo.jgp)就可以了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;首先你需要在github创建一个仓储&lt;br&gt;&lt;img src=&quot;/images/build-blog/create_git_respository.png&quot; alt=&quot;ii1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装git-npm&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux 使用技巧</title>
    <link href="http://474172261.github.io/2020/03/29/linux-skill/"/>
    <id>http://474172261.github.io/2020/03/29/linux-skill/</id>
    <published>2020-03-28T23:53:23.767Z</published>
    <updated>2020-04-13T06:37:17.776Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>不定期更新</p></blockquote><h2 id="两个linux文件互传"><a href="#两个linux文件互传" class="headerlink" title="两个linux文件互传"></a>两个linux文件互传</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r linux-2.6.26 root@(目标ip)IP:/usr/src/(假设放到/usr/src路径)</span><br></pre></td></tr></table></figure><h2 id="将一个本地程序做成一个本地服务程序"><a href="#将一个本地程序做成一个本地服务程序" class="headerlink" title="将一个本地程序做成一个本地服务程序"></a>将一个本地程序做成一个本地服务程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ socat tcp<span class="_">-l</span>:2333,reuseaddr,fork <span class="built_in">exec</span>:./pwn1</span><br></pre></td></tr></table></figure><p>服务端口在2333，使用nc 127.0.0.1 2333连接</p><h2 id="快速转换图片格式，修改分辨率"><a href="#快速转换图片格式，修改分辨率" class="headerlink" title="快速转换图片格式，修改分辨率"></a>快速转换图片格式，修改分辨率</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ convert -resize 100x100 src.jpg dst.jpg</span><br><span class="line">$ convert -resize 50%x50% src.jpg dst.jpg</span><br></pre></td></tr></table></figure><h2 id="修改文件的用户"><a href="#修改文件的用户" class="headerlink" title="修改文件的用户"></a>修改文件的用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看归属：</span><br><span class="line">$ ls -l file</span><br><span class="line"></span><br><span class="line">赋给用户hv</span><br><span class="line">$ chown hv:hv file</span><br><span class="line"></span><br><span class="line">如果需要把某个文件夹下所有都付给某个用户</span><br><span class="line">$ chown hv:hv -R dir/*</span><br></pre></td></tr></table></figure><h2 id="修改terminal的显示路径"><a href="#修改terminal的显示路径" class="headerlink" title="修改terminal的显示路径"></a>修改terminal的显示路径</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## If this is an xterm set the title to user@host:dir</span><br><span class="line">case “$TERM” in</span><br><span class="line">xterm|rxvt)</span><br><span class="line">PS1&#x3D;”\e]0;$debianchroot:+($debianchroot)\u@\h:\w\a$PS1”</span><br></pre></td></tr></table></figure><p>将PS1那行修改为(其实就是把w换成W)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1&#x3D;”[\u@\h:\W]\\$”</span><br></pre></td></tr></table></figure><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/victorv</span><br></pre></td></tr></table></figure><h2 id="创建terminal的快捷键"><a href="#创建terminal的快捷键" class="headerlink" title="创建terminal的快捷键"></a>创建terminal的快捷键</h2><p>如果是在kali，terminal是没有快捷键的，到设置的keyboard里面，添加自定义快捷键，键值为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnome-terminal</span><br></pre></td></tr></table></figure><p>或者安装nautilus-open-terminal</p><h2 id="gdb改变汇编代码显示方式"><a href="#gdb改变汇编代码显示方式" class="headerlink" title="gdb改变汇编代码显示方式"></a>gdb改变汇编代码显示方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set disas intel</span><br></pre></td></tr></table></figure><p>设置反汇编代码使用的指令集，可选择 intel 指令集或 AT&amp;T指令集.</p><h2 id="usb驱动相关"><a href="#usb驱动相关" class="headerlink" title="usb驱动相关"></a>usb驱动相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">查找usb驱动</span><br><span class="line">$ sudo lspci</span><br><span class="line">…</span><br><span class="line">02:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168B PCI Express Gigabit Ethernet controller (rev 01)</span><br><span class="line">$ find /sys | grep drivers.*02:00</span><br><span class="line"></span><br><span class="line">获取usb设备信息</span><br><span class="line">lsusb -t</span><br><span class="line">cat /proc/bus/usb/devices</span><br><span class="line">lshw</span><br><span class="line"></span><br><span class="line">卸载usb驱动</span><br><span class="line">tree /sys/bus/usb/drivers</span><br><span class="line"><span class="built_in">echo</span> -n “1-1:1.0” &gt; /sys/bus/usb/drivers/ub/unbind</span><br></pre></td></tr></table></figure><h2 id="centos安装内核header"><a href="#centos安装内核header" class="headerlink" title="centos安装内核header"></a>centos安装内核header</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install kernel-devel-$(uname -r) kernel-headers-$(uname -r)</span><br></pre></td></tr></table></figure><p>如果遇到没有搜索结果, 可以做如下操作:</p><ol><li>查看当前版本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos~]<span class="comment"># cat /etc/redhat-release</span></span><br><span class="line">CentOS release 5.6 (Final)</span><br></pre></td></tr></table></figure></li><li>修改文件<code>/etc/yum.repos.d/CentOS-Vault.repo</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[C(Your Version Number)-base] 比如 [C5.6-base]</span><br><span class="line">name&#x3D;CentOS-(Your Version Number) - Base</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;vault.centos.org&#x2F;(Your Version Number)&#x2F;os&#x2F;$basearch&#x2F;</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-5</span><br><span class="line">enabled&#x3D;1</span><br><span class="line"></span><br><span class="line">[C(Your Version Number-updates]</span><br><span class="line">name&#x3D;CentOS-(Your Version Number) - Updates</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;vault.centos.org&#x2F;(Your Version Number)&#x2F;updates&#x2F;$basearch&#x2F;</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-5</span><br><span class="line">enabled&#x3D;1</span><br></pre></td></tr></table></figure></li></ol><p>之后再试一次install即可.</p><p>更多参考<a href="http://wiki.r1soft.com/display/kb3/Finding+Old+kernel-devel+Packages+For+CentOS" target="_blank" rel="noopener">Finding Old kernel-devel Packages For CentOS</a></p><h2 id="添加sudoer-并且取消密码"><a href="#添加sudoer-并且取消密码" class="headerlink" title="添加sudoer 并且取消密码"></a>添加sudoer 并且取消密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">superuser ALL=(ALL) NOPASSWD:ALL</span><br><span class="line">superuser ALL=(ALL:ALL) ALL　<span class="comment">#不取消密码</span></span><br></pre></td></tr></table></figure><h2 id="创建ssh服务"><a href="#创建ssh服务" class="headerlink" title="创建ssh服务"></a>创建ssh服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install openssh-server openssh-clients</span><br><span class="line">$ chkconfig sshd on</span><br><span class="line">$ service sshd start</span><br><span class="line">$ netstat -tulpn | grep :22</span><br><span class="line">$ vi /etc/sysconfig/iptables -A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT</span><br></pre></td></tr></table></figure><h2 id="创建ftp-服务"><a href="#创建ftp-服务" class="headerlink" title="创建ftp 服务"></a>创建ftp 服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install vsftpd</span><br><span class="line">sudo service vsftpd restart</span><br><span class="line">chkconfig vsftpd on</span><br></pre></td></tr></table></figure><h2 id="ubuntu修改内核调试启动项"><a href="#ubuntu修改内核调试启动项" class="headerlink" title="ubuntu修改内核调试启动项"></a>ubuntu修改内核调试启动项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/default/grub</span><br></pre></td></tr></table></figure><p>在屁股后面添加 kgdboc=ttyS1,115200</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep menu /boot/grub/grub.cfg</span><br><span class="line">grub-reboot ‘1&gt;3’</span><br></pre></td></tr></table></figure><p>第一个数字1代表第二行的submenu，第二个3代表submenu的第四个（从0开始）</p><h2 id="挂起一个进程"><a href="#挂起一个进程" class="headerlink" title="挂起一个进程"></a>挂起一个进程</h2><p>ctrl+z<br>fg 恢复</p><h2 id="打包、解压文件"><a href="#打包、解压文件" class="headerlink" title="打包、解压文件"></a>打包、解压文件</h2><p>解包使用x,打包使用c</p><p>tar.xz<br>解包:tar zxvf file.tar.xz 或者:xz -d file.tar.xz &amp;&amp; tar xvf file.tar<br>打包:tar zcvf file.tar.xz</p><p>.tar<br>解包：tar xvf FileName.tar<br>打包：tar cvf FileName.tar DirName<br>（注：tar是打包，不是压缩！）<br>———————————————<br>.gz<br>解压1：gunzip FileName.gz<br>解压2：gzip -d FileName.gz<br>压缩：gzip FileName</p><p>.tar.gz 和 .tgz<br>解压：tar zxvf FileName.tar.gz<br>压缩：tar zcvf FileName.tar.gz DirName<br>———————————————<br>.bz2<br>解压1：bzip2 -d FileName.bz2<br>解压2：bunzip2 FileName.bz2<br>压缩： bzip2 -z FileName</p><p>.tar.bz2<br>解压：tar jxvf FileName.tar.bz2<br>压缩：tar jcvf FileName.tar.bz2 DirName<br>———————————————<br>.bz<br>解压1：bzip2 -d FileName.bz<br>解压2：bunzip2 FileName.bz<br>压缩：未知</p><p>.tar.bz<br>解压：tar jxvf FileName.tar.bz<br>压缩：未知<br>———————————————<br>.Z<br>解压：uncompress FileName.Z<br>压缩：compress FileName<br>.tar.Z</p><p>解压：tar Zxvf FileName.tar.Z<br>压缩：tar Zcvf FileName.tar.Z DirName<br>———————————————<br>.zip<br>解压：unzip FileName.zip<br>压缩：zip FileName.zip DirName<br>———————————————<br>.rar<br>解压：rar x FileName.rar<br>压缩：rar a FileName.rar DirName<br>———————————————<br>.lha<br>解压：lha -e FileName.lha<br>压缩：lha -a FileName.lha FileName<br>———————————————<br>.rpm<br>解包：rpm2cpio FileName.rpm | cpio -div<br>———————————————<br>.deb<br>解包：ar p FileName.deb data.tar.gz | tar zxf -<br>———————————————<br>.tar .tgz .tar.gz .tar.Z .tar.bz .tar.bz2 .zip .cpio .rpm .deb .slp .arj .rar .ace .lha .lzh .lzx .lzs .arc .sda .sfx .lnx .zoo .cab .kar .cpt .pit .sit .sea<br>解压：sEx x FileName.*<br>压缩：sEx a FileName.* FileName</p><h2 id="单独重新编译一个内核模块"><a href="#单独重新编译一个内核模块" class="headerlink" title="单独重新编译一个内核模块"></a>单独重新编译一个内核模块</h2><p>当我们想修改内核某个模块,又不想重新make all的时候,可以这样操作.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make drivers&#x2F;net&#x2F;ethernet&#x2F;intel&#x2F;e1000&#x2F;e1000.ko</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make drivers&#x2F;net&#x2F;ethernet&#x2F;intel&#x2F;e1000&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;blockquote&gt;
&lt;p&gt;不定期更新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;两个linux文件互传&quot;&gt;&lt;a href=&quot;#两个linux文件互传&quot; class=&quot;headerlink&quot; title=&quot;两个linux文件互传
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
